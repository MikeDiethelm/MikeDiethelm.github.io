import { Translations } from '../translation.service';

export const DE_TRANSLATIONS: Translations = {
    // Navigation
    'nav.home': 'Home',
    'nav.weather': 'Wetter',
    'nav.crypto': 'Krypto',
    'nav.angular': 'Angular',
    'nav.playground': 'Playground',
    'nav.features': 'Features',

    // Home Component
    'home.greeting': 'Hi, ich bin',
    'home.subtitle': 'Fullstack Developer',
    'home.intro': 'Willkommen auf meiner Portfolio-Seite! Ich bin ein leidenschaftlicher Entwickler mit Fokus auf Angular und moderne Webtechnologien. Hier demonstriere ich meine Kenntnisse durch verschiedene Features und Projekte.',
    'home.linkedin': 'LinkedIn',
    'home.cta.viewPortfolio': 'Portfolio ansehen',
    'home.cta.contact': 'Kontakt aufnehmen',
    'home.stats.yearsExperience': 'Jahre Erfahrung',
    'home.stats.projects': 'Projekte',
    'home.stats.technologies': 'Technologien',
    'home.stats.engagement': 'Engagement',
    'home.skills.title': 'Meine Expertise',
    'home.skills.subtitle': 'Technologien und Tools mit denen ich täglich arbeite',
    'home.skills.frontend': 'Frontend',
    'home.skills.backend': 'Backend & APIs',
    'home.skills.tools': 'Tools & DevOps',
    'home.projects.title': 'Ausgewählte Projekte',
    'home.projects.subtitle': 'Entdecke meine neuesten Arbeiten und technischen Demonstrationen',
    'home.projects.viewAll': 'Alle Projekte ansehen',
    'home.features.title': 'Feature Demonstrationen',
    'home.features.weather.title': 'Wetter-App',
    'home.features.weather.description': 'Vollständige Wetter-Anwendung mit kostenloser API-Integration',
    'home.features.weather.button': 'Wetter ansehen',
    'home.features.crypto.title': 'Krypto-Tracker',
    'home.features.crypto.description': 'Live-Preise und 24h-Veränderungen der Top-Kryptowährungen',
    'home.features.crypto.button': 'Krypto ansehen',
    'home.features.angular.title': 'Angular v20 Best Practices',
    'home.features.angular.description': 'Umfassende Zusammenfassung moderner Angular-Entwicklung mit Signals und Standalone Components',
    'home.features.angular.button': 'Angular ansehen',
    'home.features.all.button': 'Alle Features',

    // Technology names
    'tech.angular': 'Angular',
    'tech.typescript': 'TypeScript',
    'tech.scss': 'SCSS',
    'tech.material': 'Material Design',
    'tech.rxjs': 'RxJS',
    'tech.restful': 'RESTful APIs',
    'tech.httpclient': 'HttpClient',
    'tech.state': 'State Management',
    'tech.node': 'Node.js',
    'tech.git': 'Git',
    'tech.vscode': 'VS Code',
    'tech.npm': 'NPM',
    'tech.webpack': 'Webpack',
    'tech.openweather': 'OpenWeather API',
    'tech.coingecko': 'CoinGecko API',
    'tech.charts': 'Charts',

    // Weather Component
    'weather.title': 'Wettervorhersage',
    'weather.subtitle': 'Aktuelle Wetterdaten für deine Stadt',
    'weather.search.label': 'Stadt eingeben',
    'weather.search.placeholder': 'z.B. Berlin, München, Zürich...',
    'weather.search.button': 'Suchen',
    'weather.loading': 'Lädt...',
    'weather.error': 'Fehler beim Laden der Wetterdaten',
    'weather.error.title': 'Fehler aufgetreten',
    'weather.error.tip': 'Tipp',
    'weather.error.suggestion': 'Prüfe die Schreibweise oder versuche es mit einem anderen Stadtnamen',
    'weather.error.close': 'Schließen',
    'weather.popular.title': 'Beliebte Städte',
    'weather.refresh': 'Aktualisieren',
    'weather.lastUpdated': 'Zuletzt aktualisiert',
    'weather.backToHome.button': 'Zurück zur Startseite',
    'weather.backToHome.tooltip': 'Zurück zur Startseite',
    'weather.feelsLike': 'Gefühlt',
    'weather.minMax': 'Min/Max',
    'weather.humidity': 'Luftfeuchtigkeit',
    'weather.pressure': 'Luftdruck',
    'weather.wind': 'Wind',
    'weather.sunrise': 'Sonnenaufgang',
    'weather.sunset': 'Sonnenuntergang',

    // Crypto Component
    'crypto.title': 'Kryptowährungen',
    'crypto.subtitle': 'Live-Preise der Top Kryptowährungen',
    'crypto.loading': 'Lädt...',
    'crypto.refresh.button': 'Aktualisieren',
    'crypto.refresh.tooltip': 'Daten neu laden',
    'crypto.currency.label': 'Währung:',
    'crypto.error.title': 'Fehler beim Laden',
    'crypto.error.dismiss': 'Schließen',
    'crypto.lastUpdate': 'Letztes Update',
    'crypto.dataStale': 'Daten möglicherweise veraltet',
    'crypto.topCurrencies': 'Top Kryptowährungen',
    'crypto.table.rank': 'Rang',
    'crypto.table.name': 'Name',
    'crypto.table.price': 'Preis',
    'crypto.table.change24h': '24h Veränderung',
    'crypto.table.marketCap': 'Marktkapitalisierung',
    'crypto.marketSize.label': 'Marktgröße',
    'crypto.marketSize.top100': 'Top 100 Coins',
    'crypto.marketSize.top250': 'Top 250 Coins',
    'crypto.marketSize.top500': 'Top 500 Coins',
    'crypto.marketSize.top1000': 'Top 1.000 Coins',
    'crypto.marketSize.top2500': 'Top 2.500 Coins',
    'crypto.pageSize.label': 'Coins pro Seite',
    'crypto.pageSize.coinsPerPage': 'Coins pro Seite',
    'crypto.pagination.showing': 'Anzeige',
    'crypto.pagination.of': 'von',
    'crypto.pagination.previous': 'Vorherige Seite',
    'crypto.pagination.next': 'Nächste Seite',
    'crypto.empty.title': 'Keine Daten verfügbar',
    'crypto.empty.subtitle': 'Klicke auf "Daten laden" um die aktuellen Kryptowährungspreise zu sehen.',
    'crypto.loadData': 'Daten laden',
    'crypto.clickForDetails': 'Klicken für Details',
    'crypto.backToHome.button': 'Zur Startseite',
    'crypto.backToHome.tooltip': 'Zurück zur Startseite',

    // Angular Summary Component
    'angular.header.title': 'Angular v20 Best Practices & Zusammenfassung',
    'angular.header.subtitle': 'Moderne Webentwicklung mit Angular 20 - Signals, Standalone Components & mehr',
    'angular.backToHome': 'Zurück zur Startseite',
    'angular.sections.coreFeatures': 'Kern-Features',
    'angular.sections.bestPractices': 'Best Practices',
    'angular.sections.technologies': 'Verwendete Technologien',
    'angular.sections.examples': 'Code-Beispiele',
    'angular.sections.advanced': 'Erweiterte Themen',
    'angular.sections.architecture': 'Architektur-Muster',
    'angular.sections.tools': 'CLI & DevTools',
    'angular.sections.realWorldPatterns': 'Real-World Patterns',
    'angular.sections.realWorldPatternsDesc': 'Praxisbewährte Lösungen für häufige Entwicklungsszenarien',
    'angular.sections.developmentTools': 'Entwicklungs-Tools',
    'angular.sections.developmentToolsDesc': 'Moderne Werkzeuge und Konfigurationen für professionelle Angular-Entwicklung',
    'angular.sections.deployment': 'Deployment-Strategien',
    'angular.sections.deploymentDesc': 'Best Practices für CI/CD, Docker und Cloud-Deployment',
    'angular.sections.accessibility': 'Barrierefreiheit (a11y)',
    'angular.sections.accessibilityDesc': 'WCAG-konforme Implementierungen für inklusive Webanwendungen',
    'angular.sections.commonPitfalls': 'Häufige Fehler & Anti-Patterns',
    'angular.sections.commonPitfallsDesc': 'Typische Stolpersteine vermeiden und sauberen Code schreiben',
    'angular.sections.resources': 'Ressourcen & Links',
    'angular.sections.resourcesDesc': 'Nützliche Quellen für weiteres Lernen und Community-Support',

    // Common translations
    'angular.common.clickForDetails': 'Klick für Details',
    'angular.common.useCases': 'Anwendungsfälle',
    'angular.common.implementation': 'Implementierung',
    'angular.common.setup': 'Installation & Setup',
    'angular.common.configuration': 'Konfiguration',
    'angular.common.steps': 'Schritte',
    'angular.common.example': 'Beispiel',
    'angular.common.bestPractices': 'Best Practices',
    'angular.common.benefits': 'Vorteile',
    'angular.common.challenges': 'Herausforderungen',
    'angular.common.problem': 'Problem',
    'angular.common.solution': 'Lösung',
    'angular.features.signals.title': 'Signals',
    'angular.features.signals.description': 'Reaktives State Management mit signal(), computed() und effect() für optimale Performance',
    'angular.features.standalone.title': 'Standalone Components',
    'angular.features.standalone.description': 'Modullose Architektur - Komponenten sind standardmäßig standalone',
    'angular.features.inject.title': 'inject() Funktion',
    'angular.features.inject.description': 'Dependency Injection mit inject() statt Constructor-Injection',
    'angular.features.controlFlow.title': 'Control Flow',
    'angular.features.controlFlow.description': 'Native @if, @for, @switch Syntax statt struktureller Direktiven',
    'angular.features.deferrable.title': 'Deferrable Views (@defer)',
    'angular.features.deferrable.description': 'Lazy Loading von Templates mit @defer, @placeholder, @loading und @error Blöcken',
    'angular.features.inputOutput.title': 'input() & output() Funktionen',
    'angular.features.inputOutput.description': 'Signal-basierte Component Inputs und Outputs ersetzen @Input() und @Output() Decorators',
    'angular.features.viewQueries.title': 'viewChild() & viewChildren()',
    'angular.features.viewQueries.description': 'Signal-basierte View Queries für type-safe Zugriff auf Child Components und DOM-Elemente',
    'angular.features.model.title': 'model() für Two-Way Binding',
    'angular.features.model.description': 'Vereinfachtes Two-Way Data Binding mit WritableSignal für bidirektionale Kommunikation',
    'angular.features.onPush.title': 'OnPush Change Detection',
    'angular.features.onPush.description': 'Optimierte Performance durch ChangeDetectionStrategy.OnPush',
    'angular.features.httpClient.title': 'HttpClient mit Signals',
    'angular.features.httpClient.description': 'Moderne HTTP-Kommunikation mit provideHttpClient(withFetch())',
    'angular.features.resource.title': 'Resource API (Experimental)',
    'angular.features.resource.description': 'Deklarative HTTP-Requests mit automatischem Loading State und Error Handling',
    'angular.features.typedForms.title': 'Typed Reactive Forms',
    'angular.features.typedForms.description': 'Vollständig typisierte Forms mit FormControl<T>, FormGroup<T> und FormArray<T>',
    'angular.features.router.title': 'Standalone Router',
    'angular.features.router.description': 'Funktionales Routing mit provideRouter(), Guards, Resolvers und Lazy Loading',
    'angular.features.material.title': 'Material Design 3',
    'angular.features.material.description': 'Angular Material Components mit Material Design 3 Theming und Accessibility',
    'angular.features.devtools.title': 'Angular DevTools',
    'angular.features.devtools.description': 'Browser Extension für Component Inspection, Profiling und Dependency Injection Debugging',
    'angular.features.vite.title': 'Vite & ESBuild',
    'angular.features.vite.description': 'Ultraschnelle Build-Zeiten mit Vite Dev Server und ESBuild für Production Builds',
    'angular.bestPractices.components.title': 'Komponenten',
    'angular.bestPractices.components.item1': 'Kleine, fokussierte Komponenten mit Single Responsibility',
    'angular.bestPractices.components.item2': 'input() und output() Funktionen statt Decorators',
    'angular.bestPractices.components.item3': 'Inline Templates für kleine Komponenten bevorzugen',
    'angular.bestPractices.components.item4': 'OnPush Change Detection für optimale Performance',
    'angular.bestPractices.components.item5': 'class und style Bindings statt ngClass/ngStyle',
    'angular.bestPractices.components.item6': 'Lifecycle Hooks implementieren (OnInit, OnDestroy, etc.)',
    'angular.bestPractices.components.item7': 'Protected für Template-only Members, Private für interne Logik',
    'angular.bestPractices.components.item8': 'Komplexe Template-Logik in computed() Signals auslagern',
    'angular.bestPractices.state.title': 'State Management',
    'angular.bestPractices.state.item1': 'Signals für lokalen Komponenten-State verwenden',
    'angular.bestPractices.state.item2': 'computed() für abgeleiteten State nutzen',
    'angular.bestPractices.state.item3': 'State-Transformationen pure und vorhersagbar halten',
    'angular.bestPractices.state.item4': 'update() oder set() verwenden, nie mutate()',
    'angular.bestPractices.state.item5': 'effect() nur für Seiteneffekte, nicht für State-Updates',
    'angular.bestPractices.state.item6': 'untracked() nutzen um zirkuläre Dependencies zu vermeiden',
    'angular.bestPractices.templates.title': 'Templates',
    'angular.bestPractices.templates.item1': 'Native Control Flow (@if, @for, @switch) verwenden',
    'angular.bestPractices.templates.item2': 'Templates einfach halten, komplexe Logik vermeiden',
    'angular.bestPractices.templates.item3': 'Async Pipe für Observables nutzen',
    'angular.bestPractices.templates.item4': 'trackBy mit @for für effizientes List-Rendering',
    'angular.bestPractices.templates.item5': '@defer für Lazy Loading schwerer Components nutzen',
    'angular.bestPractices.services.title': 'Services',
    'angular.bestPractices.services.item1': 'Services um Single Responsibility designen',
    'angular.bestPractices.services.item2': 'providedIn: "root" für Singleton Services',
    'angular.bestPractices.services.item3': 'inject() Funktion statt Constructor Injection',
    'angular.bestPractices.services.item4': 'Readonly exposed State mit privaten Signals für Mutationen',
    'angular.bestPractices.services.item5': 'Service-Logik von Präsentations-Logik trennen',
    'angular.bestPractices.performance.title': 'Performance',
    'angular.bestPractices.performance.item1': 'OnPush Change Detection konsequent einsetzen',
    'angular.bestPractices.performance.item2': 'Lazy Loading für Feature Routes implementieren',
    'angular.bestPractices.performance.item3': 'NgOptimizedImage für statische Bilder verwenden',
    'angular.bestPractices.performance.item4': 'TrackBy bei @for verwenden für optimales Rendering',
    'angular.bestPractices.performance.item5': '@defer für on-demand Component Loading nutzen',
    'angular.bestPractices.performance.item6': 'Pure Pipes bevorzugen (default), Impure nur wenn nötig',
    'angular.bestPractices.performance.item7': 'Web Workers für CPU-intensive Berechnungen einsetzen',
    'angular.bestPractices.typescript.title': 'TypeScript',
    'angular.bestPractices.typescript.item1': 'Strict Type Checking aktiviert',
    'angular.bestPractices.typescript.item2': 'Type Inference nutzen wenn offensichtlich',
    'angular.bestPractices.typescript.item3': 'any vermeiden, unknown bei Unsicherheit verwenden',
    'angular.bestPractices.typescript.item4': 'readonly für Properties die nicht ändern',
    'angular.bestPractices.typescript.item5': 'const für alle Variablen die nicht reassigned werden',
    'angular.bestPractices.typescript.item6': 'Explizite Return-Types für öffentliche API-Methoden',
    'angular.bestPractices.accessibility.title': 'Accessibility (a11y)',
    'angular.bestPractices.accessibility.item1': 'Semantische HTML-Elemente verwenden',
    'angular.bestPractices.accessibility.item2': 'ARIA-Labels für dynamische Inhalte hinzufügen',
    'angular.bestPractices.accessibility.item3': 'Keyboard-Navigation für alle interaktiven Elemente',
    'angular.bestPractices.accessibility.item4': 'Ausreichende Farbkontraste (WCAG 2.1 AA)',
    'angular.bestPractices.accessibility.item5': 'Focus-Management bei modalen Dialogen und Routen',
    'angular.bestPractices.testing.title': 'Testing',
    'angular.bestPractices.testing.item1': 'Unit Tests für alle Business-Logic schreiben',
    'angular.bestPractices.testing.item2': 'TestBed für Component Tests mit Dependency Injection',
    'angular.bestPractices.testing.item3': 'Signals mit TestBed.inject() und fixture.detectChanges() testen',
    'angular.bestPractices.testing.item4': 'Mock Services für isolierte Component Tests',
    'angular.bestPractices.testing.item5': 'E2E Tests für kritische User Journeys (Cypress/Playwright)',
    'angular.bestPractices.errorHandling.title': 'Error Handling',
    'angular.bestPractices.errorHandling.item1': 'Global Error Handler für unerwartete Fehler implementieren',
    'angular.bestPractices.errorHandling.item2': 'HTTP Interceptor für zentrale API-Fehlerbehandlung',
    'angular.bestPractices.errorHandling.item3': 'catchError() für Observable Error Handling nutzen',
    'angular.bestPractices.errorHandling.item4': 'User-freundliche Fehlermeldungen mit Kontext anzeigen',
    'angular.bestPractices.security.title': 'Security',
    'angular.bestPractices.security.item1': 'Sanitization für User-Input nutzen (XSS-Schutz)',
    'angular.bestPractices.security.item2': 'CSRF-Tokens bei state-changing Requests verwenden',
    'angular.bestPractices.security.item3': 'HTTP Interceptor für Authorization Headers einsetzen',
    'angular.bestPractices.security.item4': 'Keine sensiblen Daten in LocalStorage speichern',
    'angular.bestPractices.security.item5': 'Content Security Policy (CSP) konfigurieren',
    'angular.bestPractices.codeOrganization.title': 'Code-Organisation',
    'angular.bestPractices.codeOrganization.item1': 'Nach Features organisieren, nicht nach Datei-Typen',
    'angular.bestPractices.codeOrganization.item2': 'Shared/Common Module für wiederverwendbare Components',
    'angular.bestPractices.codeOrganization.item3': 'Core Module für Singleton Services und Guards',
    'angular.bestPractices.codeOrganization.item4': 'Ein Konzept pro Datei (Component, Service, etc.)',
    'angular.bestPractices.codeOrganization.item5': 'Index-Dateien (index.ts) für public API exports',
    'angular.bestPractices.dependency.title': 'Dependency Management',
    'angular.bestPractices.dependency.item1': 'Abhängigkeiten regelmäßig aktualisieren (ng update)',
    'angular.bestPractices.dependency.item2': 'Peer Dependencies beachten und kompatibel halten',
    'angular.bestPractices.dependency.item3': 'Bundle Size mit source-map-explorer überwachen',
    'angular.bestPractices.dependency.item4': 'Tree-shakeable Providers nutzen (providedIn)',
    'angular.bestPractices.buildDeploy.title': 'Build & Deployment',
    'angular.bestPractices.buildDeploy.item1': 'Production Build mit --configuration=production',
    'angular.bestPractices.buildDeploy.item2': 'AOT Compilation für bessere Performance',
    'angular.bestPractices.buildDeploy.item3': 'Environment-spezifische Konfigurationen nutzen',
    'angular.bestPractices.buildDeploy.item4': 'Source Maps nur in Development aktivieren',
    'angular.bestPractices.buildDeploy.item5': 'CI/CD Pipeline für automatisierte Tests und Deployment',
    'angular.examples.signals.title': 'Signals Beispiel',
    'angular.examples.signals.subtitle': 'Reaktives State Management',
    'angular.examples.signals.description': 'Signals bieten eine einfache und performante Möglichkeit, reaktiven State zu verwalten.',
    'angular.examples.inject.title': 'Dependency Injection',
    'angular.examples.inject.subtitle': 'Moderne DI mit inject()',
    'angular.examples.inject.description': 'Die inject() Funktion ermöglicht sauberere und besser lesbare Dependency Injection.',
    'angular.examples.controlFlow.title': 'Control Flow',
    'angular.examples.controlFlow.subtitle': 'Native Template Syntax',
    'angular.examples.controlFlow.description': 'Native @if, @else Syntax ist intuitiver und performanter als *ngIf.',
    'angular.actions.title': 'Bereit für mehr?',
    'angular.actions.description': 'Erkunde weitere Funktionen und Projekte auf meiner Portfolio-Seite oder lerne mehr über Angular.',
    'angular.actions.backHome': 'Zur Startseite',
    'angular.actions.learnMore': 'Mehr über Angular',

    // Detailed Code Examples
    'angular.sections.detailedExamples': 'Detaillierte Code-Beispiele',
    'angular.sections.detailedExamplesDesc': 'Praktische Implementierungen moderner Angular v20 Patterns',
    'angular.codeExamples.signals.title': 'Signals API',
    'angular.codeExamples.signals.subtitle': 'Reaktives State Management',
    'angular.codeExamples.signals.description': 'Signals bieten eine einfache und performante API für reaktiven State. Mit signal(), computed() und effect() können komplexe Datenflüsse elegant umgesetzt werden.',
    'angular.codeExamples.component.title': 'Moderne Komponente',
    'angular.codeExamples.component.subtitle': 'input(), output() & model()',
    'angular.codeExamples.component.description': 'Neue Signal-basierte APIs für Component Inputs, Outputs und Two-Way Binding ersetzen Property/Event Decorators.',
    'angular.codeExamples.controlFlow.title': 'Control Flow Syntax',
    'angular.codeExamples.controlFlow.subtitle': '@if, @for, @switch',
    'angular.codeExamples.controlFlow.description': 'Native Template Syntax für Bedingungen und Schleifen - performanter und intuitiver als strukturelle Direktiven.',
    'angular.codeExamples.service.title': 'Service mit Signals',
    'angular.codeExamples.service.subtitle': 'State Management Pattern',
    'angular.codeExamples.service.description': 'Services nutzen Signals für State Management mit readonly exposed State und privaten Mutationen.',
    'angular.codeExamples.routing.title': 'Lazy Loading Routing',
    'angular.codeExamples.routing.subtitle': 'loadComponent & loadChildren',
    'angular.codeExamples.routing.description': 'Standalone Components ermöglichen einfaches Lazy Loading ohne NgModules.',
    'angular.codeExamples.forms.title': 'Reactive Forms',
    'angular.codeExamples.forms.subtitle': 'FormControl mit Signals',
    'angular.codeExamples.forms.description': 'Reactive Forms mit toSignal() für optimale Integration von RxJS und Signals.',
    'angular.codeExamples.rxjs.title': 'RxJS Interop',
    'angular.codeExamples.rxjs.subtitle': 'toSignal & toObservable',
    'angular.codeExamples.rxjs.description': 'Nahtlose Integration zwischen Signals und Observables mit den Interop-Funktionen.',
    'angular.codeExamples.guards.title': 'Functional Guards',
    'angular.codeExamples.guards.subtitle': 'Route Protection',
    'angular.codeExamples.guards.description': 'Moderne Guards als Funktionen statt Klassen - einfacher und testbarer.',
    'angular.codeExamples.pipes.title': 'Custom Pipes',
    'angular.codeExamples.pipes.subtitle': 'Transform & Pure',
    'angular.codeExamples.pipes.description': 'Pure Pipes für effiziente Datentransformation mit automatischem Caching.',
    'angular.codeExamples.interceptor.title': 'HTTP Interceptor',
    'angular.codeExamples.interceptor.subtitle': 'Functional Interceptors',
    'angular.codeExamples.interceptor.description': 'Moderne funktionale Interceptors mit inject() für Auth und Error Handling.',
    'angular.codeExamples.directive.title': 'Custom Directive',
    'angular.codeExamples.directive.subtitle': 'Signal-basiert',
    'angular.codeExamples.directive.description': 'Directives mit Signal Inputs und Host Bindings ohne Decorators.',
    'angular.codeExamples.deferrable.title': 'Deferrable Views',
    'angular.codeExamples.deferrable.subtitle': '@defer Syntax',
    'angular.codeExamples.deferrable.description': 'Lazy Loading von Templates mit @defer, @placeholder und @loading Blöcken.',
    'angular.codeExamples.viewChild.title': 'View Queries',
    'angular.codeExamples.viewChild.subtitle': 'viewChild & viewChildren',
    'angular.codeExamples.viewChild.description': 'Signal-basierte View Queries für type-safe Component und Element Zugriff.',
    'angular.codeExamples.hostBinding.title': 'Host Bindings',
    'angular.codeExamples.hostBinding.subtitle': 'Component Host',
    'angular.codeExamples.hostBinding.description': 'Deklarative Host Bindings für Class, Style, Attribute und Events im host object.',
    'angular.codeExamples.contentChild.title': 'Content Projection',
    'angular.codeExamples.contentChild.subtitle': 'contentChild Queries',
    'angular.codeExamples.contentChild.description': 'Content Queries mit contentChild und contentChildren für ng-content Zugriff.',
    'angular.codeExamples.testing.title': 'Component Testing',
    'angular.codeExamples.testing.subtitle': 'Jasmine & TestBed',
    'angular.codeExamples.testing.description': 'Unit Tests für Signals, computed Values und Component Interaktionen.',
    'angular.codeExamples.resource.title': 'Resource API',
    'angular.codeExamples.resource.subtitle': 'Deklarative HTTP-Anfragen',
    'angular.codeExamples.resource.description': 'Experimentelle Resource API für automatisches Loading, Error und Data State Management.',
    'angular.codeExamples.animations.title': 'Animationen',
    'angular.codeExamples.animations.subtitle': 'Angular Animations',
    'angular.codeExamples.animations.description': 'Deklarative Animationen mit Triggers, States, Transitions und komplexen Sequenzen.',
    'angular.codeExamples.stateManagement.title': 'State Management',
    'angular.codeExamples.stateManagement.subtitle': 'Zentraler App Store',
    'angular.codeExamples.stateManagement.description': 'Signal-basierter zentraler Store mit computed State und Actions für globales State Management.',
    'angular.codeExamples.httpSignals.title': 'HTTP mit Signals',
    'angular.codeExamples.httpSignals.subtitle': 'toSignal & toObservable',
    'angular.codeExamples.httpSignals.description': 'Reaktive HTTP-Kommunikation mit toSignal für Observable-zu-Signal Konvertierung.',
    'angular.codeExamples.performance.title': 'Performance Optimierung',
    'angular.codeExamples.performance.subtitle': 'OnPush & TrackBy',
    'angular.codeExamples.performance.description': 'Best Practices für optimale Performance: OnPush, TrackBy, Virtual Scrolling und Lazy Loading.',

    // Advanced Topics
    'angular.advanced.routing.title': 'Routing & Navigation',
    'angular.advanced.routing.description': 'Leistungsstarkes Routing-System mit Guards, Resolver und Lazy Loading',
    'angular.advanced.routing.topic1': 'Functional Route Guards (canActivate, canDeactivate)',
    'angular.advanced.routing.topic2': 'Route Resolver für Data Preloading',
    'angular.advanced.routing.topic3': 'Lazy Loading mit loadComponent() und loadChildren()',
    'angular.advanced.routing.topic4': 'Child Routes und verschachtelte Layouts',
    'angular.advanced.routing.topic5': 'Route Parameters und Query Parameters',
    'angular.advanced.routing.topic6': 'Preloading Strategies für optimale Performance',
    'angular.advanced.forms.title': 'Reactive Forms',
    'angular.advanced.forms.description': 'Typsichere Formularverarbeitung mit Validierung und dynamischen Controls',
    'angular.advanced.forms.topic1': 'Typed Reactive Forms mit FormControl<T>',
    'angular.advanced.forms.topic2': 'Custom Validators (sync & async)',
    'angular.advanced.forms.topic3': 'Dynamic Forms mit FormBuilder und FormArray',
    'angular.advanced.forms.topic4': 'Form State Management mit valueChanges und statusChanges',
    'angular.advanced.forms.topic5': 'Custom Form Controls mit ControlValueAccessor',
    'angular.advanced.forms.topic6': 'Form Validation Error Handling und Display',
    'angular.advanced.rxjs.title': 'RxJS Patterns & Operators',
    'angular.advanced.rxjs.description': 'Reaktive Programmierung mit Observables, Subjects und Operators',
    'angular.advanced.rxjs.topic1': 'toSignal() und toObservable() für Signal/Observable Interop',
    'angular.advanced.rxjs.topic2': 'Higher-Order Operators (switchMap, mergeMap, concatMap)',
    'angular.advanced.rxjs.topic3': 'Error Handling mit catchError und retry',
    'angular.advanced.rxjs.topic4': 'Multicasting mit Subject, BehaviorSubject, ReplaySubject',
    'angular.advanced.rxjs.topic5': 'Combination Operators (combineLatest, forkJoin, zip)',
    'angular.advanced.rxjs.topic6': 'Memory Leak Prevention und Unsubscribe Patterns',
    'angular.advanced.changeDetection.title': 'Change Detection Deep Dive',
    'angular.advanced.changeDetection.description': 'Optimierung der Change Detection für maximale Performance',
    'angular.advanced.changeDetection.topic1': 'Default vs OnPush Change Detection Strategies',
    'angular.advanced.changeDetection.topic2': 'Zone.js und NgZone für asynchrone Updates',
    'angular.advanced.changeDetection.topic3': 'Manual Change Detection mit ChangeDetectorRef',
    'angular.advanced.changeDetection.topic4': 'Signals und Zone-less Change Detection',
    'angular.advanced.changeDetection.topic5': 'Performance Profiling mit Angular DevTools',
    'angular.advanced.animations.title': 'Animations API',
    'angular.advanced.animations.description': 'Deklarative Animationen mit Angular Animations',
    'angular.advanced.animations.topic1': 'State-based Animations mit trigger, state, transition',
    'angular.advanced.animations.topic2': 'Enter/Leave Animations für @if und @for',
    'angular.advanced.animations.topic3': 'Keyframe Animations und Animation Curves',
    'angular.advanced.animations.topic4': 'Animation Callbacks und Events',
    'angular.advanced.animations.topic5': 'Reusable Animation Functions',
    'angular.advanced.testing.title': 'Testing Strategies',
    'angular.advanced.testing.description': 'Umfassendes Testing mit Jasmine, Karma und Playwright',
    'angular.advanced.testing.topic1': 'Component Testing mit TestBed und ComponentFixture',
    'angular.advanced.testing.topic2': 'Signal Testing mit TestBed.inject() und runInInjectionContext',
    'angular.advanced.testing.topic3': 'Service Mocking und Spy Pattern',
    'angular.advanced.testing.topic4': 'HttpClientTestingModule für HTTP Testing',
    'angular.advanced.testing.topic5': 'E2E Testing mit Playwright oder Cypress',
    'angular.advanced.testing.topic6': 'Code Coverage und Test Reporting',
    'angular.advanced.ssr.title': 'Server-Side Rendering & Hydration',
    'angular.advanced.ssr.description': 'SSR für bessere Performance, SEO und Core Web Vitals',
    'angular.advanced.ssr.topic1': 'Angular Universal Setup und Configuration',
    'angular.advanced.ssr.topic2': 'Non-destructive Hydration für nahtlose Client-Übernahme',
    'angular.advanced.ssr.topic3': 'Static Site Generation (SSG) mit Prerendering',
    'angular.advanced.ssr.topic4': '@defer für Progressive Hydration',
    'angular.advanced.ssr.topic5': 'Transfer State für Server-zu-Client Datentransfer',
    'angular.advanced.ssr.topic6': 'Platform-specific Code mit isPlatformBrowser/Server',
    'angular.advanced.i18n.title': 'Internationalisierung (i18n)',
    'angular.advanced.i18n.description': 'Multi-Language Support und Lokalisierung',
    'angular.advanced.i18n.topic1': 'Custom Translation Service mit Signal-basierten Übersetzungen',
    'angular.advanced.i18n.topic2': '@angular/localize für Build-Time Translation',
    'angular.advanced.i18n.topic3': 'ICU Message Format für Plurals und Select',
    'angular.advanced.i18n.topic4': 'Runtime Language Switching',
    'angular.advanced.i18n.topic5': 'Date, Number, Currency Pipes mit Locale',
    'angular.advanced.security.title': 'Security Best Practices',
    'angular.advanced.security.description': 'Eingebaute Sicherheitsfunktionen und Best Practices',
    'angular.advanced.security.topic1': 'DomSanitizer für XSS-Schutz bei dynamischem HTML',
    'angular.advanced.security.topic2': 'CSRF Protection mit HttpClient',
    'angular.advanced.security.topic3': 'Content Security Policy (CSP) Configuration',
    'angular.advanced.security.topic4': 'Trusted Types API Support',
    'angular.advanced.security.topic5': 'Secure Authentication mit JWT und HTTP Interceptors',
    'angular.advanced.security.topic6': 'HTTPS Enforcement und Secure Cookies',
    'angular.advanced.directives.title': 'Advanced Directives',
    'angular.advanced.directives.description': 'Strukturelle und Attribut-Directives für erweiterte Templates',
    'angular.advanced.directives.topic1': 'Custom Structural Directives mit ng-template',
    'angular.advanced.directives.topic2': 'Attribute Directives mit Signal Inputs',
    'angular.advanced.directives.topic3': 'Host Bindings und Host Listeners im host object',
    'angular.advanced.directives.topic4': 'Directive Composition API',
    'angular.advanced.directives.topic5': 'Renderer2 für platform-safe DOM Manipulation',
    'angular.advanced.pipes.title': 'Custom Pipes',
    'angular.advanced.pipes.description': 'Pure und Impure Pipes für Datentransformation',
    'angular.advanced.pipes.topic1': 'Pure Pipes mit automatischem Caching',
    'angular.advanced.pipes.topic2': 'Impure Pipes für dynamic Data',
    'angular.advanced.pipes.topic3': 'Async Pipe für Observable/Promise Handling',
    'angular.advanced.pipes.topic4': 'Parameterized Pipes',
    'angular.advanced.pipes.topic5': 'Performance Considerations und Best Practices',
    'angular.advanced.httpInterceptors.title': 'HTTP Interceptors',
    'angular.advanced.httpInterceptors.description': 'Request/Response Interception für Auth, Logging und Error Handling',
    'angular.advanced.httpInterceptors.topic1': 'Functional Interceptors mit HttpInterceptorFn',
    'angular.advanced.httpInterceptors.topic2': 'Authentication Interceptor für JWT Tokens',
    'angular.advanced.httpInterceptors.topic3': 'Error Handling und Retry Logic',
    'angular.advanced.httpInterceptors.topic4': 'Request/Response Logging',
    'angular.advanced.httpInterceptors.topic5': 'Multiple Interceptors und Execution Order',
    'angular.advanced.stateManagement.title': 'State Management Patterns',
    'angular.advanced.stateManagement.description': 'Verschiedene Ansätze für Application State Management',
    'angular.advanced.stateManagement.topic1': 'Signal-based State Management mit Services',
    'angular.advanced.stateManagement.topic2': 'NgRx Store für komplexes State Management',
    'angular.advanced.stateManagement.topic3': 'NGRX Signal Store (neue Signal-basierte API)',
    'angular.advanced.stateManagement.topic4': 'Component Store für lokalen Feature State',
    'angular.advanced.stateManagement.topic5': 'RxJS-based State Management mit BehaviorSubject',
    'angular.advanced.moduleFederation.title': 'Module Federation',
    'angular.advanced.moduleFederation.description': 'Micro-Frontend Architektur mit Webpack Module Federation',
    'angular.advanced.moduleFederation.topic1': 'Module Federation Setup mit @angular-architects/module-federation',
    'angular.advanced.moduleFederation.topic2': 'Remote Module Loading zur Laufzeit',
    'angular.advanced.moduleFederation.topic3': 'Shared Dependencies Management',
    'angular.advanced.moduleFederation.topic4': 'Micro-Frontend Communication Patterns',
    'angular.advanced.pwa.title': 'Progressive Web Apps (PWA)',
    'angular.advanced.pwa.description': 'App-ähnliche Erfahrung mit Service Workers und Offline Support',
    'angular.advanced.pwa.topic1': '@angular/pwa Setup und Configuration',
    'angular.advanced.pwa.topic2': 'Service Worker Caching Strategies',
    'angular.advanced.pwa.topic3': 'Offline Support und Background Sync',
    'angular.advanced.pwa.topic4': 'Push Notifications',
    'angular.advanced.pwa.topic5': 'App Manifest und Install Prompts',
    'angular.architecture.smartDumb.title': 'Smart & Dumb Components',
    'angular.architecture.smartDumb.description': 'Trennung von Container- (smart) und Präsentations-Komponenten (dumb) für bessere Wartbarkeit',
    'angular.architecture.smartDumb.detailTitle': 'Smart & Dumb Components Pattern',
    'angular.architecture.smartDumb.explanation': 'Das Smart & Dumb Components Pattern trennt Komponenten in Container-Komponenten (smart), die Geschäftslogik und State Management handhaben, und Präsentations-Komponenten (dumb), die nur für die Darstellung zuständig sind.',
    'angular.architecture.smartDumb.benefit1': 'Bessere Wiederverwendbarkeit durch isolierte Präsentations-Komponenten',
    'angular.architecture.smartDumb.benefit2': 'Einfacheres Testing - Dumb Components benötigen keine Service-Mocks',
    'angular.architecture.smartDumb.benefit3': 'Optimierte Performance durch OnPush Change Detection',
    'angular.architecture.smartDumb.benefit4': 'Klare Verantwortlichkeiten - leichtere Wartung',
    'angular.architecture.smartDumb.useCase1': 'Listen-Komponenten mit Daten-Lade-Logik',
    'angular.architecture.smartDumb.useCase2': 'Formular-Container mit Validierung und API-Calls',
    'angular.architecture.smartDumb.useCase3': 'Dashboard-Widgets mit State Management',
    'angular.architecture.smartDumb.implementation1': 'Smart Components nutzen Services und Signals für State',
    'angular.architecture.smartDumb.implementation2': 'Dumb Components verwenden input() und output() für Kommunikation',
    'angular.architecture.smartDumb.implementation3': 'Dumb Components setzen ChangeDetectionStrategy.OnPush',
    'angular.architecture.smartDumb.implementation4': 'Keine direkten Service-Injections in Dumb Components',
    'angular.architecture.smartDumb.challenge1': 'Prop-Drilling bei tief verschachtelten Komponenten',
    'angular.architecture.smartDumb.challenge2': 'Boilerplate für Input/Output Bindings',

    'angular.architecture.facade.title': 'Facade Pattern',
    'angular.architecture.facade.description': 'Vereinfachte API für komplexe State-Management-Logik',
    'angular.architecture.facade.detailTitle': 'Facade Pattern',
    'angular.architecture.facade.explanation': 'Das Facade Pattern bietet eine vereinfachte, einheitliche Schnittstelle zu mehreren komplexen Services. Es bündelt State Management, API-Calls und Business-Logik hinter einer einfachen API.',
    'angular.architecture.facade.benefit1': 'Reduzierte Komplexität für Komponenten',
    'angular.architecture.facade.benefit2': 'Zentrale Stelle für Feature-Logik',
    'angular.architecture.facade.benefit3': 'Einfacheres Refactoring durch Kapselung',
    'angular.architecture.facade.benefit4': 'Bessere Testbarkeit',
    'angular.architecture.facade.useCase1': 'State Management mit mehreren Services',
    'angular.architecture.facade.useCase2': 'Koordination von API-Calls',
    'angular.architecture.facade.useCase3': 'Feature-spezifische Business-Logik',
    'angular.architecture.facade.implementation1': 'Facade Service injiziert alle benötigten Services',
    'angular.architecture.facade.implementation2': 'Exponiert Observables für reactive State',
    'angular.architecture.facade.implementation3': 'Bietet Aktions-Methoden für alle Operations',
    'angular.architecture.facade.implementation4': 'Handled Error-Management zentral',
    'angular.architecture.facade.challenge1': 'Kann zu "God Objects" werden',
    'angular.architecture.facade.challenge2': 'Zusätzliche Abstraktionsebene',

    'angular.architecture.module.title': 'Feature Module',
    'angular.architecture.module.description': 'Organisierung von Features in wiederverwendbare Module',
    'angular.architecture.module.detailTitle': 'Feature Module Pattern',
    'angular.architecture.module.explanation': 'Feature Modules gruppieren zusammengehörige Funktionalität in eigene Module. Mit Standalone Components werden Features über Routes und Barrel Exports organisiert.',
    'angular.architecture.module.benefit1': 'Klare Feature-Grenzen',
    'angular.architecture.module.benefit2': 'Wiederverwendbarkeit',
    'angular.architecture.module.benefit3': 'Bessere Code-Organisation',
    'angular.architecture.module.benefit4': 'Ermöglicht Lazy Loading',
    'angular.architecture.module.useCase1': 'Große Applikationen mit mehreren Features',
    'angular.architecture.module.useCase2': 'Wiederverwendbare UI-Komponenten',
    'angular.architecture.module.useCase3': 'Shared Services und Utilities',
    'angular.architecture.module.implementation1': 'CoreModule für Singleton Services',
    'angular.architecture.module.implementation2': 'SharedModule für gemeinsame Components',
    'angular.architecture.module.implementation3': 'Feature Routes mit loadChildren',
    'angular.architecture.module.implementation4': 'Barrel Exports (index.ts) für saubere Imports',
    'angular.architecture.module.challenge1': 'Module-Boundaries müssen durchdacht werden',
    'angular.architecture.module.challenge2': 'Circular Dependencies vermeiden',

    'angular.architecture.lazy.title': 'Lazy Loading',
    'angular.architecture.lazy.description': 'On-Demand-Laden von Features für schnellere Initial Loads',
    'angular.architecture.lazy.detailTitle': 'Lazy Loading Pattern',
    'angular.architecture.lazy.explanation': 'Lazy Loading lädt Features nur bei Bedarf. Dies reduziert die initiale Bundle-Größe und beschleunigt den ersten Seitenaufruf erheblich.',
    'angular.architecture.lazy.benefit1': 'Kleinere Initial Bundle Size',
    'angular.architecture.lazy.benefit2': 'Schnellerer Initial Load',
    'angular.architecture.lazy.benefit3': 'Bessere Performance',
    'angular.architecture.lazy.benefit4': 'On-Demand Resource Loading',
    'angular.architecture.lazy.useCase1': 'Admin-Bereiche',
    'angular.architecture.lazy.useCase2': 'Selten genutzte Features',
    'angular.architecture.lazy.useCase3': 'Große Feature-Module',
    'angular.architecture.lazy.implementation1': 'loadChildren() in Routes',
    'angular.architecture.lazy.implementation2': 'loadComponent() für einzelne Components',
    'angular.architecture.lazy.implementation3': 'PreloadingStrategy für intelligentes Preloading',
    'angular.architecture.lazy.implementation4': 'Route Guards für Access Control',
    'angular.architecture.lazy.challenge1': 'Loading-Verzögerung beim ersten Zugriff',
    'angular.architecture.lazy.challenge2': 'Komplexere Build-Konfiguration',

    'angular.architecture.repository.title': 'Repository Pattern',
    'angular.architecture.repository.description': 'Zentrale Datenzugriffs-Schicht für API-Kommunikation und Caching',
    'angular.architecture.repository.detailTitle': 'Repository Pattern',
    'angular.architecture.repository.explanation': 'Das Repository Pattern abstrahiert den Datenzugriff hinter einer einheitlichen Schnittstelle. Es trennt Business-Logik von Daten-Zugriffs-Logik.',
    'angular.architecture.repository.benefit1': 'Zentrale Datenzugriffs-Logik',
    'angular.architecture.repository.benefit2': 'Austauschbare Datenquellen',
    'angular.architecture.repository.benefit3': 'Einfaches Mocking für Tests',
    'angular.architecture.repository.benefit4': 'Einheitliche Error-Handling',
    'angular.architecture.repository.useCase1': 'REST API Zugriff',
    'angular.architecture.repository.useCase2': 'Local Storage Abstraktion',
    'angular.architecture.repository.useCase3': 'Caching-Layer',
    'angular.architecture.repository.implementation1': 'Generic Base Repository',
    'angular.architecture.repository.implementation2': 'Repository Interface',
    'angular.architecture.repository.implementation3': 'Spezifische Repositories erweitern Base',
    'angular.architecture.repository.implementation4': 'Error-Handling in Base-Methoden',
    'angular.architecture.repository.challenge1': 'Zusätzliche Abstraktionsebene',
    'angular.architecture.repository.challenge2': 'Overhead für einfache CRUD',

    'angular.architecture.observer.title': 'Observer Pattern',
    'angular.architecture.observer.description': 'Event-basierte Kommunikation mit RxJS Observables und Subjects',
    'angular.architecture.observer.detailTitle': 'Observer Pattern',
    'angular.architecture.observer.explanation': 'Das Observer Pattern ermöglicht reaktive Programmierung mit RxJS. Komponenten abonnieren Datenströme und reagieren automatisch auf Änderungen.',
    'angular.architecture.observer.benefit1': 'Reaktive Datenströme',
    'angular.architecture.observer.benefit2': 'Lose Kopplung',
    'angular.architecture.observer.benefit3': 'Automatische Updates',
    'angular.architecture.observer.benefit4': 'Mächtiges Operator-System',
    'angular.architecture.observer.useCase1': 'State Management',
    'angular.architecture.observer.useCase2': 'Event-Bus Systeme',
    'angular.architecture.observer.useCase3': 'Real-time Daten',
    'angular.architecture.observer.implementation1': 'Subject für Events',
    'angular.architecture.observer.implementation2': 'BehaviorSubject für State',
    'angular.architecture.observer.implementation3': 'ReplaySubject für Caching',
    'angular.architecture.observer.implementation4': 'takeUntil für Memory-Leak Prevention',
    'angular.architecture.observer.challenge1': 'Subscription Management',
    'angular.architecture.observer.challenge2': 'Komplexe RxJS Operatoren',

    'angular.architecture.singleton.title': 'Singleton Pattern',
    'angular.architecture.singleton.description': 'Shared Services mit providedIn: "root" für app-weiten State',
    'angular.architecture.singleton.detailTitle': 'Singleton Pattern',
    'angular.architecture.singleton.explanation': 'Singleton Services existieren nur einmal in der gesamten Applikation. Angular\'s Dependency Injection erstellt automatisch Singletons mit providedIn: "root".',
    'angular.architecture.singleton.benefit1': 'Shared State über gesamte App',
    'angular.architecture.singleton.benefit2': 'Effiziente Ressourcen-Nutzung',
    'angular.architecture.singleton.benefit3': 'Zentrale Konfiguration',
    'angular.architecture.singleton.benefit4': 'Einfaches Dependency Injection',
    'angular.architecture.singleton.useCase1': 'Auth Services',
    'angular.architecture.singleton.useCase2': 'Configuration Services',
    'angular.architecture.singleton.useCase3': 'Logging Services',
    'angular.architecture.singleton.implementation1': 'providedIn: "root"',
    'angular.architecture.singleton.implementation2': 'CoreModule mit forRoot()',
    'angular.architecture.singleton.implementation3': 'Import Guards in CoreModule',
    'angular.architecture.singleton.implementation4': 'ApplicationConfig providers',
    'angular.architecture.singleton.challenge1': 'Testing kann komplexer sein',
    'angular.architecture.singleton.challenge2': 'Globaler State schwer zu tracken',

    'angular.architecture.decorator.title': 'Decorator Pattern',
    'angular.architecture.decorator.description': 'Erweiterung von Funktionalität mit @Component, @Injectable und Custom Decorators',
    'angular.architecture.decorator.detailTitle': 'Decorator Pattern',
    'angular.architecture.decorator.explanation': 'Decorators erweitern Klassen, Methoden oder Properties mit zusätzlicher Funktionalität. TypeScript Decorators sind die Basis von Angular.',
    'angular.architecture.decorator.benefit1': 'Wiederverwendbare Cross-Cutting Concerns',
    'angular.architecture.decorator.benefit2': 'Sauberer, deklarativer Code',
    'angular.architecture.decorator.benefit3': 'Metadata für Reflection',
    'angular.architecture.decorator.benefit4': 'Aspect-Oriented Programming',
    'angular.architecture.decorator.useCase1': 'Logging',
    'angular.architecture.decorator.useCase2': 'Caching/Memoization',
    'angular.architecture.decorator.useCase3': 'Auto-Unsubscribe',
    'angular.architecture.decorator.implementation1': 'Method Decorators',
    'angular.architecture.decorator.implementation2': 'Class Decorators',
    'angular.architecture.decorator.implementation3': 'Property Decorators',
    'angular.architecture.decorator.implementation4': 'Parameter Decorators',
    'angular.architecture.decorator.challenge1': 'TypeScript experimentalDecorators',
    'angular.architecture.decorator.challenge2': 'Debugging kann schwieriger sein',

    'angular.architecture.strategy.title': 'Strategy Pattern',
    'angular.architecture.strategy.description': 'Austauschbare Algorithmen mit Change Detection Strategies und Guards',
    'angular.architecture.strategy.detailTitle': 'Strategy Pattern',
    'angular.architecture.strategy.explanation': 'Das Strategy Pattern ermöglicht Auswahl von Algorithmen zur Laufzeit. Verschiedene Implementierungen einer Schnittstelle können dynamisch ausgetauscht werden.',
    'angular.architecture.strategy.benefit1': 'Flexible Algorithmen-Auswahl',
    'angular.architecture.strategy.benefit2': 'Open/Closed Principle',
    'angular.architecture.strategy.benefit3': 'Einfaches Testen einzelner Strategien',
    'angular.architecture.strategy.benefit4': 'Runtime-Konfigurierbarkeit',
    'angular.architecture.strategy.useCase1': 'Validierung',
    'angular.architecture.strategy.useCase2': 'Sortier-Algorithmen',
    'angular.architecture.strategy.useCase3': 'Payment Processing',
    'angular.architecture.strategy.implementation1': 'Strategy Interface definieren',
    'angular.architecture.strategy.implementation2': 'Konkrete Strategy-Klassen',
    'angular.architecture.strategy.implementation3': 'Context verwendet Strategy',
    'angular.architecture.strategy.implementation4': 'DI für Strategy-Injection',
    'angular.architecture.strategy.challenge1': 'Mehr Klassen erforderlich',
    'angular.architecture.strategy.challenge2': 'Strategie-Auswahl-Logik nötig',

    'angular.architecture.adapter.title': 'Adapter Pattern',
    'angular.architecture.adapter.description': 'Transformation externer APIs in interne Interfaces mit Services',
    'angular.architecture.adapter.detailTitle': 'Adapter Pattern',
    'angular.architecture.adapter.explanation': 'Das Adapter Pattern wandelt eine Schnittstelle in eine andere um. Perfekt für Integration externer APIs in interne Domain Models.',
    'angular.architecture.adapter.benefit1': 'Entkopplung von externen APIs',
    'angular.architecture.adapter.benefit2': 'Konsistente interne Models',
    'angular.architecture.adapter.benefit3': 'Einfacher API-Wechsel',
    'angular.architecture.adapter.benefit4': 'Type-Safety',
    'angular.architecture.adapter.useCase1': 'REST API Integration',
    'angular.architecture.adapter.useCase2': 'Legacy System Integration',
    'angular.architecture.adapter.useCase3': 'Third-Party Libraries',
    'angular.architecture.adapter.implementation1': 'Adapter Service erstellen',
    'angular.architecture.adapter.implementation2': 'Mapping-Methoden',
    'angular.architecture.adapter.implementation3': 'RxJS map() Operator',
    'angular.architecture.adapter.implementation4': 'Type-Guards für Validierung',
    'angular.architecture.adapter.challenge1': 'Zusätzlicher Mapping-Code',
    'angular.architecture.adapter.challenge2': 'Performance bei großen Datenmengen',

    'angular.architecture.featureSlice.title': 'Feature-Slice Architecture',
    'angular.architecture.featureSlice.description': 'Organisation nach Features statt Typen - jedes Feature enthält Components, Services, State',
    'angular.architecture.featureSlice.detailTitle': 'Feature-Slice Architecture',
    'angular.architecture.featureSlice.explanation': 'Feature-Slice Architecture organisiert Code nach Business-Features statt nach technischen Typen. Jedes Feature ist ein autonomer Slice mit eigenen Components, Services und State.',
    'angular.architecture.featureSlice.benefit1': 'Bessere Feature-Kohäsion',
    'angular.architecture.featureSlice.benefit2': 'Einfachere Navigation im Code',
    'angular.architecture.featureSlice.benefit3': 'Team-Ownership pro Feature',
    'angular.architecture.featureSlice.benefit4': 'Reduzierte Coupling zwischen Features',
    'angular.architecture.featureSlice.useCase1': 'Große Enterprise Applikationen',
    'angular.architecture.featureSlice.useCase2': 'Multi-Team Entwicklung',
    'angular.architecture.featureSlice.useCase3': 'Microservices-ähnliche Frontend-Struktur',
    'angular.architecture.featureSlice.implementation1': 'Feature-Ordner mit Data/Domain/UI',
    'angular.architecture.featureSlice.implementation2': 'Feature Facade als API',
    'angular.architecture.featureSlice.implementation3': 'Feature Routes',
    'angular.architecture.featureSlice.implementation4': 'Barrel Exports',
    'angular.architecture.featureSlice.challenge1': 'Shared Code zwischen Features',
    'angular.architecture.featureSlice.challenge2': 'Feature-Boundaries definieren',

    'angular.architecture.cleanArchitecture.title': 'Clean Architecture',
    'angular.architecture.cleanArchitecture.description': 'Trennung in Layers: Presentation, Domain, Data - Abhängigkeiten zeigen nach innen',
    'angular.architecture.cleanArchitecture.detailTitle': 'Clean Architecture',
    'angular.architecture.cleanArchitecture.explanation': 'Clean Architecture trennt Code in konzentrische Layer. Abhängigkeiten zeigen immer nach innen: Presentation → Application → Domain. Der Domain-Layer ist unabhängig.',
    'angular.architecture.cleanArchitecture.benefit1': 'Hohe Testbarkeit',
    'angular.architecture.cleanArchitecture.benefit2': 'Framework-Unabhängigkeit',
    'angular.architecture.cleanArchitecture.benefit3': 'Klare Verantwortlichkeiten',
    'angular.architecture.cleanArchitecture.benefit4': 'Langfristige Wartbarkeit',
    'angular.architecture.cleanArchitecture.useCase1': 'Komplexe Business-Logik',
    'angular.architecture.cleanArchitecture.useCase2': 'Long-lived Applikationen',
    'angular.architecture.cleanArchitecture.useCase3': 'Team mit DDD-Erfahrung',
    'angular.architecture.cleanArchitecture.implementation1': 'Domain Layer mit Entities',
    'angular.architecture.cleanArchitecture.implementation2': 'Use Cases im Application Layer',
    'angular.architecture.cleanArchitecture.implementation3': 'Infrastructure für externe Services',
    'angular.architecture.cleanArchitecture.implementation4': 'Presentation mit Components',
    'angular.architecture.cleanArchitecture.challenge1': 'Hoher initialer Aufwand',
    'angular.architecture.cleanArchitecture.challenge2': 'Viel Boilerplate',

    'angular.architecture.cqrs.title': 'CQRS Pattern',
    'angular.architecture.cqrs.description': 'Command Query Responsibility Segregation - Trennung von Read und Write Operations',
    'angular.architecture.cqrs.detailTitle': 'CQRS Pattern',
    'angular.architecture.cqrs.explanation': 'CQRS trennt Lese- (Queries) und Schreib-Operationen (Commands). Commands ändern State, Queries nur lesen ihn. Beide können unterschiedlich optimiert werden.',
    'angular.architecture.cqrs.benefit1': 'Optimierte Read/Write Models',
    'angular.architecture.cqrs.benefit2': 'Skalierbarkeit',
    'angular.architecture.cqrs.benefit3': 'Klarere Intentionen',
    'angular.architecture.cqrs.benefit4': 'Event Sourcing möglich',
    'angular.architecture.cqrs.useCase1': 'Komplexe Domain Models',
    'angular.architecture.cqrs.useCase2': 'Unterschiedliche Read/Write Last',
    'angular.architecture.cqrs.useCase3': 'Event-basierte Systeme',
    'angular.architecture.cqrs.implementation1': 'Command und Query Interfaces',
    'angular.architecture.cqrs.implementation2': 'CommandBus und QueryBus',
    'angular.architecture.cqrs.implementation3': 'Separate Handler',
    'angular.architecture.cqrs.implementation4': 'Event Publishing nach Commands',
    'angular.architecture.cqrs.challenge1': 'Erhöhte Komplexität',
    'angular.architecture.cqrs.challenge2': 'Eventual Consistency',

    'angular.architecture.eventDriven.title': 'Event-Driven Architecture',
    'angular.architecture.eventDriven.description': 'Lose gekoppelte Komponenten kommunizieren über Events und Observables',
    'angular.architecture.eventDriven.detailTitle': 'Event-Driven Architecture',
    'angular.architecture.eventDriven.explanation': 'Event-Driven Architecture nutzt Events als primäres Kommunikationsmittel. Komponenten reagieren auf Events statt direkt miteinander zu kommunizieren.',
    'angular.architecture.eventDriven.benefit1': 'Lose Kopplung',
    'angular.architecture.eventDriven.benefit2': 'Hohe Erweiterbarkeit',
    'angular.architecture.eventDriven.benefit3': 'Einfaches Hinzufügen neuer Features',
    'angular.architecture.eventDriven.benefit4': 'Audit Trail möglich',
    'angular.architecture.eventDriven.useCase1': 'Komplexe User Flows',
    'angular.architecture.eventDriven.useCase2': 'Analytics Integration',
    'angular.architecture.eventDriven.useCase3': 'State Synchronisation',
    'angular.architecture.eventDriven.implementation1': 'Event Bus Service',
    'angular.architecture.eventDriven.implementation2': 'Domain Events',
    'angular.architecture.eventDriven.implementation3': 'Event Handler Services',
    'angular.architecture.eventDriven.implementation4': 'Type-Safe Events',
    'angular.architecture.eventDriven.challenge1': 'Schwieriges Debugging',
    'angular.architecture.eventDriven.challenge2': 'Event-Ordering-Probleme',

    'angular.architecture.microFrontends.title': 'Micro Frontends',
    'angular.architecture.microFrontends.description': 'Modulare Frontend-Architektur mit Module Federation und unabhängigen Teams',
    'angular.architecture.microFrontends.detailTitle': 'Micro Frontends',
    'angular.architecture.microFrontends.explanation': 'Micro Frontends erweitern das Microservices-Konzept auf das Frontend. Unabhängige Teams entwickeln und deployen Features autonom mit Module Federation.',
    'angular.architecture.microFrontends.benefit1': 'Unabhängige Deployments',
    'angular.architecture.microFrontends.benefit2': 'Team-Autonomie',
    'angular.architecture.microFrontends.benefit3': 'Technologie-Flexibilität',
    'angular.architecture.microFrontends.benefit4': 'Skalierbare Teams',
    'angular.architecture.microFrontends.useCase1': 'Große Enterprise Portale',
    'angular.architecture.microFrontends.useCase2': 'Multi-Team Organisation',
    'angular.architecture.microFrontends.useCase3': 'Legacy Migration',
    'angular.architecture.microFrontends.implementation1': 'Webpack Module Federation',
    'angular.architecture.microFrontends.implementation2': 'Shell und Remote Apps',
    'angular.architecture.microFrontends.implementation3': 'Shared Dependencies',
    'angular.architecture.microFrontends.implementation4': 'Event Bus für Communication',
    'angular.architecture.microFrontends.challenge1': 'Komplexe Build-Konfiguration',
    'angular.architecture.microFrontends.challenge2': 'Versionierungs-Management',

    'angular.architecture.ddd.title': 'Domain-Driven Design',
    'angular.architecture.ddd.description': 'Modellierung komplexer Business-Logik mit Aggregates, Entities und Value Objects',
    'angular.architecture.ddd.detailTitle': 'Domain-Driven Design',
    'angular.architecture.ddd.explanation': 'DDD fokussiert auf die Business-Domäne. Entities, Value Objects und Aggregates modellieren komplexe Business-Regeln. Die Ubiquitous Language verbindet Dev und Business.',
    'angular.architecture.ddd.benefit1': 'Business-fokussierte Modelle',
    'angular.architecture.ddd.benefit2': 'Gemeinsame Sprache',
    'angular.architecture.ddd.benefit3': 'Klare Domain-Grenzen',
    'angular.architecture.ddd.benefit4': 'Robuste Business-Logik',
    'angular.architecture.ddd.useCase1': 'Komplexe Business-Domänen',
    'angular.architecture.ddd.useCase2': 'Long-term Projects',
    'angular.architecture.ddd.useCase3': 'Eng mit Business arbeitende Teams',
    'angular.architecture.ddd.implementation1': 'Entities mit Identity',
    'angular.architecture.ddd.implementation2': 'Value Objects immutable',
    'angular.architecture.ddd.implementation3': 'Aggregate Roots',
    'angular.architecture.ddd.implementation4': 'Domain Services',
    'angular.architecture.ddd.challenge1': 'Steile Lernkurve',
    'angular.architecture.ddd.challenge2': 'Overhead für einfache Domänen',

    'angular.architecture.hexagonal.title': 'Hexagonal Architecture',
    'angular.architecture.hexagonal.description': 'Ports & Adapters Pattern - Core Business Logic isoliert von externer Infrastruktur',
    'angular.architecture.hexagonal.detailTitle': 'Hexagonal Architecture (Ports & Adapters)',
    'angular.architecture.hexagonal.explanation': 'Die Hexagonale Architektur trennt die Domain-Logik vollständig von externer Infrastruktur. Ports definieren Interfaces, Adapters implementieren diese für konkrete Technologien.',
    'angular.architecture.hexagonal.benefit1': 'Vollständige Testbarkeit der Domain-Logik',
    'angular.architecture.hexagonal.benefit2': 'Austauschbare Infrastruktur-Komponenten',
    'angular.architecture.hexagonal.benefit3': 'Klare Abhängigkeitsrichtung nach innen',
    'angular.architecture.hexagonal.benefit4': 'Unabhängigkeit von Frameworks',
    'angular.architecture.hexagonal.useCase1': 'Geschäftskritische Anwendungen',
    'angular.architecture.hexagonal.useCase2': 'Migration von Legacy-Systemen',
    'angular.architecture.hexagonal.useCase3': 'Multi-Channel-Anwendungen',
    'angular.architecture.hexagonal.implementation1': 'Port-Interfaces in Domain definieren',
    'angular.architecture.hexagonal.implementation2': 'Use Cases mit Port-Abhängigkeiten',
    'angular.architecture.hexagonal.implementation3': 'Adapters für HTTP, Datenbank, etc.',
    'angular.architecture.hexagonal.implementation4': 'DI-Konfiguration für Port-Adapter-Binding',
    'angular.architecture.hexagonal.challenge1': 'Mehr Abstraktions-Overhead',
    'angular.architecture.hexagonal.challenge2': 'Komplexität für einfache Apps',

    'angular.architecture.stateManagement.title': 'Centralized State Management',
    'angular.architecture.stateManagement.description': 'Zentraler App-State mit Signal Store, NgRx oder Akita für vorhersagbaren Datenaustausch',
    'angular.architecture.stateManagement.detailTitle': 'Centralized State Management',
    'angular.architecture.stateManagement.explanation': 'Centralized State Management verwaltet den gesamten App-Zustand an einer zentralen Stelle. Mit Signals, NgRx oder Akita wird State vorhersagbar und nachvollziehbar.',
    'angular.architecture.stateManagement.benefit1': 'Single Source of Truth',
    'angular.architecture.stateManagement.benefit2': 'Vorhersagbare State-Updates',
    'angular.architecture.stateManagement.benefit3': 'Debugging und Time-Travel',
    'angular.architecture.stateManagement.benefit4': 'Einfaches State-Sharing',
    'angular.architecture.stateManagement.useCase1': 'Komplexe Datenflüsse',
    'angular.architecture.stateManagement.useCase2': 'Multi-View-Synchronisation',
    'angular.architecture.stateManagement.useCase3': 'Offline-fähige Apps',
    'angular.architecture.stateManagement.implementation1': 'Signal Store mit computed Selectors',
    'angular.architecture.stateManagement.implementation2': 'Immutable State Updates',
    'angular.architecture.stateManagement.implementation3': 'Action-Methods für Mutations',
    'angular.architecture.stateManagement.implementation4': 'Service Injection in Components',
    'angular.architecture.stateManagement.challenge1': 'Boilerplate-Code',
    'angular.architecture.stateManagement.challenge2': 'Lernkurve für komplexe Stores',

    'angular.architecture.onion.title': 'Onion Architecture',
    'angular.architecture.onion.description': 'Schichten-Architektur mit Domain Core im Zentrum, umgeben von Application und Infrastructure',
    'angular.architecture.onion.detailTitle': 'Onion Architecture',
    'angular.architecture.onion.explanation': 'Die Onion Architecture organisiert Code in konzentrischen Schichten. Der Domain Core im Zentrum hat keine Abhängigkeiten, äußere Schichten hängen von inneren ab.',
    'angular.architecture.onion.benefit1': 'Domain-Logik völlig unabhängig',
    'angular.architecture.onion.benefit2': 'Klare Schichtentrennung',
    'angular.architecture.onion.benefit3': 'Hohe Testbarkeit',
    'angular.architecture.onion.benefit4': 'Langfristige Wartbarkeit',
    'angular.architecture.onion.useCase1': 'Enterprise Applications',
    'angular.architecture.onion.useCase2': 'Langlebige Projekte',
    'angular.architecture.onion.useCase3': 'Team-übergreifende Entwicklung',
    'angular.architecture.onion.implementation1': 'Domain Entities ohne Dependencies',
    'angular.architecture.onion.implementation2': 'Domain Services Layer',
    'angular.architecture.onion.implementation3': 'Application Services mit Use Cases',
    'angular.architecture.onion.implementation4': 'Infrastructure & Presentation außen',
    'angular.architecture.onion.challenge1': 'Viele Schichten erhöhen Komplexität',
    'angular.architecture.onion.challenge2': 'Schwierig für kleine Projekte',

    'angular.architecture.mvvm.title': 'MVVM Pattern',
    'angular.architecture.mvvm.description': 'Model-View-ViewModel Pattern mit Reactive Forms und Data Binding als ViewModel-Layer',
    'angular.architecture.mvvm.detailTitle': 'MVVM Pattern',
    'angular.architecture.mvvm.explanation': 'MVVM trennt View (Template), ViewModel (Component mit Reactive Forms) und Model (Domain). Data Binding synchronisiert View und ViewModel automatisch.',
    'angular.architecture.mvvm.benefit1': 'Klare Separation of Concerns',
    'angular.architecture.mvvm.benefit2': 'Testbare View-Logik',
    'angular.architecture.mvvm.benefit3': 'Reaktive Datenflüsse',
    'angular.architecture.mvvm.benefit4': 'Two-Way Binding Vorteile',
    'angular.architecture.mvvm.useCase1': 'Formular-lastige Anwendungen',
    'angular.architecture.mvvm.useCase2': 'Dashboard-Views',
    'angular.architecture.mvvm.useCase3': 'Data-Entry-Screens',
    'angular.architecture.mvvm.implementation1': 'Reactive Forms als ViewModel',
    'angular.architecture.mvvm.implementation2': 'Computed Properties für View-State',
    'angular.architecture.mvvm.implementation3': 'Commands als Component Methods',
    'angular.architecture.mvvm.implementation4': 'Model-Services für Business Logic',
    'angular.architecture.mvvm.challenge1': 'ViewModel kann komplex werden',
    'angular.architecture.mvvm.challenge2': 'Overhead für einfache Views',
    'angular.tools.cli.title': 'Angular CLI',
    'angular.tools.cli.description': 'Command Line Interface für schnelle Entwicklung',
    'angular.tools.devtools.title': 'Angular DevTools',
    'angular.tools.devtools.description': 'Browser-Extension für Debugging und Profiling',
    'angular.tools.devtools.feature1': 'Component Tree Inspector',
    'angular.tools.devtools.feature2': 'Dependency Injection Visualizer',
    'angular.tools.devtools.feature3': 'Performance Profiler',
    'angular.tools.devtools.feature4': 'Change Detection Debugger',
    'angular.tools.build.title': 'Build System',
    'angular.tools.build.description': 'Modernes Build-System mit Vite und ESBuild',
    'angular.tools.build.feature1': 'Extrem schnelle Build-Zeiten',
    'angular.tools.build.feature2': 'Hot Module Replacement (HMR)',
    'angular.tools.build.feature3': 'Optimierte Production Builds',
    'angular.tools.build.feature4': 'Source Maps Support',

    // Real-World Patterns
    'angular.realWorldPatterns.errorBoundary.title': 'Error Boundary Pattern',
    'angular.realWorldPatterns.errorBoundary.description': 'Graceful Error Handling mit zentralisierten Fehlerbehandlungskomponenten',
    'angular.realWorldPatterns.errorBoundary.useCase1': 'Fehler in Child-Components abfangen',
    'angular.realWorldPatterns.errorBoundary.useCase2': 'User-freundliche Fehlermeldungen anzeigen',
    'angular.realWorldPatterns.errorBoundary.useCase3': 'Retry-Mechanismen implementieren',
    'angular.realWorldPatterns.errorBoundary.useCase4': 'Fehler zentral loggen und tracken',
    'angular.realWorldPatterns.loadingState.title': 'Loading State Pattern',
    'angular.realWorldPatterns.loadingState.description': 'Einheitliche Verwaltung von Loading-, Error- und Empty-States',
    'angular.realWorldPatterns.loadingState.useCase1': 'Globaler Loading-Indikator',
    'angular.realWorldPatterns.loadingState.useCase2': 'Skelett-Bildschirme für bessere UX',
    'angular.realWorldPatterns.loadingState.useCase3': 'Gleichzeitige Requests koordinieren',
    'angular.realWorldPatterns.loadingState.useCase4': 'Empty States elegant darstellen',
    'angular.realWorldPatterns.retryLogic.title': 'Retry Logic Pattern',
    'angular.realWorldPatterns.retryLogic.description': 'Intelligente Retry-Strategien mit exponential backoff',
    'angular.realWorldPatterns.retryLogic.useCase1': 'Netzwerkfehler automatisch wiederholen',
    'angular.realWorldPatterns.retryLogic.useCase2': 'Rate-Limiting umgehen',
    'angular.realWorldPatterns.retryLogic.useCase3': 'Temporäre Server-Fehler behandeln',
    'angular.realWorldPatterns.retryLogic.useCase4': 'Progressive Backoff-Strategien',
    'angular.realWorldPatterns.optimisticUpdates.title': 'Optimistic Updates',
    'angular.realWorldPatterns.optimisticUpdates.description': 'Sofortige UI-Updates mit Rollback bei Fehlern',
    'angular.realWorldPatterns.optimisticUpdates.useCase1': 'Like/Unlike Features',
    'angular.realWorldPatterns.optimisticUpdates.useCase2': 'Todo-Listen Updates',
    'angular.realWorldPatterns.optimisticUpdates.useCase3': 'Formular-Submissions',
    'angular.realWorldPatterns.optimisticUpdates.useCase4': 'Shopping Cart Updates',
    'angular.realWorldPatterns.polling.title': 'Polling Pattern',
    'angular.realWorldPatterns.polling.description': 'Periodische Server-Abfragen für Echtzeit-ähnliche Updates',
    'angular.realWorldPatterns.polling.useCase1': 'Job-Status überwachen',
    'angular.realWorldPatterns.polling.useCase2': 'Dashboard-Daten aktualisieren',
    'angular.realWorldPatterns.polling.useCase3': 'Benachrichtigungen abrufen',
    'angular.realWorldPatterns.polling.useCase4': 'Live-Scores und Preise',
    'angular.realWorldPatterns.websocket.title': 'WebSocket Integration',
    'angular.realWorldPatterns.websocket.description': 'Bidirektionale Echtzeit-Kommunikation mit automatischem Reconnect',
    'angular.realWorldPatterns.websocket.useCase1': 'Chat-Anwendungen',
    'angular.realWorldPatterns.websocket.useCase2': 'Live-Collaboration',
    'angular.realWorldPatterns.websocket.useCase3': 'Echtzeit-Benachrichtigungen',
    'angular.realWorldPatterns.websocket.useCase4': 'Gaming und Live-Events',

    // Development Tools
    'angular.developmentTools.schematics.title': 'Angular Schematics',
    'angular.developmentTools.schematics.description': 'Eigene Code-Generatoren für wiederholbare Projektstrukturen',
    'angular.developmentTools.eslint.title': 'ESLint Konfiguration',
    'angular.developmentTools.eslint.description': 'Code-Qualität mit modernem ESLint 9+ Setup sicherstellen',
    'angular.developmentTools.prettier.title': 'Prettier Code Formatter',
    'angular.developmentTools.prettier.description': 'Konsistente Code-Formatierung im gesamten Team',
    'angular.developmentTools.husky.title': 'Husky Git Hooks',
    'angular.developmentTools.husky.description': 'Automatisierte Qualitätschecks vor Commits und Pushes',
    'angular.developmentTools.conventionalCommits.title': 'Conventional Commits',
    'angular.developmentTools.conventionalCommits.description': 'Standardisierte Commit-Messages für bessere Historie',

    // Deployment Strategies
    'angular.deploymentStrategies.docker.title': 'Docker Container Setup',
    'angular.deploymentStrategies.docker.description': 'Multi-stage Docker Builds für optimierte Production Images',
    'angular.deploymentStrategies.docker.step1': 'Multi-stage Dockerfile erstellen',
    'angular.deploymentStrategies.docker.step2': 'Nginx als Production Server konfigurieren',
    'angular.deploymentStrategies.docker.step3': 'Docker Compose für lokale Entwicklung',
    'angular.deploymentStrategies.docker.step4': 'Health Checks implementieren',
    'angular.deploymentStrategies.docker.step5': 'Image-Größe optimieren',
    'angular.deploymentStrategies.cicd.title': 'CI/CD Pipelines',
    'angular.deploymentStrategies.cicd.description': 'Automatisierte Builds und Deployments mit GitHub Actions und GitLab CI',
    'angular.deploymentStrategies.cicd.step1': 'Workflow-Datei erstellen',
    'angular.deploymentStrategies.cicd.step2': 'Lint, Test und Build Jobs konfigurieren',
    'angular.deploymentStrategies.cicd.step3': 'Deployment-Pipeline einrichten',
    'angular.deploymentStrategies.cicd.step4': 'Environment-spezifische Deployments',
    'angular.deploymentStrategies.cicd.step5': 'Rollback-Strategien implementieren',
    'angular.deploymentStrategies.envVariables.title': 'Environment Variables',
    'angular.deploymentStrategies.envVariables.description': 'Sichere Verwaltung von Konfiguration über Environments',
    'angular.deploymentStrategies.envVariables.step1': 'Environment-Dateien strukturieren',
    'angular.deploymentStrategies.envVariables.step2': 'Runtime-Konfiguration laden',
    'angular.deploymentStrategies.envVariables.step3': 'Docker Environment Variables',
    'angular.deploymentStrategies.envVariables.step4': 'Secrets Management',
    'angular.deploymentStrategies.featureFlags.title': 'Feature Flags',
    'angular.deploymentStrategies.featureFlags.description': 'Dynamische Feature-Steuerung ohne Redeploy',
    'angular.deploymentStrategies.featureFlags.step1': 'Feature Flag Service implementieren',
    'angular.deploymentStrategies.featureFlags.step2': 'Feature Flag Directive erstellen',
    'angular.deploymentStrategies.featureFlags.step3': 'Remote Config Integration',
    'angular.deploymentStrategies.featureFlags.step4': 'A/B Testing Setup',
    'angular.deploymentStrategies.monitoring.title': 'Monitoring & Analytics',
    'angular.deploymentStrategies.monitoring.description': 'Error Tracking, Performance Monitoring und User Analytics',
    'angular.deploymentStrategies.monitoring.step1': 'Sentry Error Tracking integrieren',
    'angular.deploymentStrategies.monitoring.step2': 'Google Analytics 4 Setup',
    'angular.deploymentStrategies.monitoring.step3': 'Performance Metriken erfassen',
    'angular.deploymentStrategies.monitoring.step4': 'Custom Logging Service',
    'angular.deploymentStrategies.monitoring.step5': 'Real User Monitoring (RUM)',

    // Accessibility Patterns
    'angular.accessibility.ariaLabels.title': 'ARIA Labels & Attributes',
    'angular.accessibility.ariaLabels.description': 'Semantische Beschriftung für assistive Technologien',
    'angular.accessibility.ariaLabels.tip1': 'Immer aria-label für Icon-Buttons verwenden',
    'angular.accessibility.ariaLabels.tip2': 'aria-describedby für zusätzliche Kontextinformationen',
    'angular.accessibility.ariaLabels.tip3': 'aria-live für dynamische Content-Updates',
    'angular.accessibility.ariaLabels.tip4': 'aria-expanded für Accordions und Dropdowns',
    'angular.accessibility.keyboardNav.title': 'Tastatur-Navigation',
    'angular.accessibility.keyboardNav.description': 'Vollständige Bedienbarkeit ohne Maus',
    'angular.accessibility.keyboardNav.tip1': 'Tab-Navigation für alle interaktiven Elemente',
    'angular.accessibility.keyboardNav.tip2': 'Pfeiltasten für Listen und Menüs',
    'angular.accessibility.keyboardNav.tip3': 'Enter/Space für Buttons und Links',
    'angular.accessibility.keyboardNav.tip4': 'Escape zum Schließen von Modals',
    'angular.accessibility.keyboardNav.tip5': 'Sichtbare Focus-Indikatoren',
    'angular.accessibility.focusManagement.title': 'Focus Management',
    'angular.accessibility.focusManagement.description': 'Intelligente Fokus-Steuerung für bessere UX',
    'angular.accessibility.focusManagement.tip1': 'Focus Trap in Modals implementieren',
    'angular.accessibility.focusManagement.tip2': 'Auto-Focus auf ersten Input in Formularen',
    'angular.accessibility.focusManagement.tip3': 'Focus nach Modal-Schließen wiederherstellen',
    'angular.accessibility.focusManagement.tip4': 'Skip-Links für schnelle Navigation',
    'angular.accessibility.screenReader.title': 'Screen Reader Support',
    'angular.accessibility.screenReader.description': 'Optimale Unterstützung für Bildschirmleseprogramme',
    'angular.accessibility.screenReader.tip1': 'Live Regions für Status-Updates',
    'angular.accessibility.screenReader.tip2': 'Screen-Reader-Only Klasse für visuelle Versteckte',
    'angular.accessibility.screenReader.tip3': 'Semantisches HTML verwenden',
    'angular.accessibility.screenReader.tip4': 'Alt-Texte für alle Bilder',
    'angular.accessibility.screenReader.tip5': 'Korrekte Heading-Hierarchie',

    // Common Pitfalls
    'angular.pitfalls.memoryLeaks.title': 'Memory Leaks vermeiden',
    'angular.pitfalls.memoryLeaks.description': 'Subscriptions und Event Listener korrekt aufräumen',
    'angular.pitfalls.changeDetection.title': 'Change Detection Probleme',
    'angular.pitfalls.changeDetection.description': 'Immutable Updates und OnPush korrekt verwenden',
    'angular.pitfalls.zoneJs.title': 'Zone.js Performance-Probleme',
    'angular.pitfalls.zoneJs.description': 'Unnötige Change Detection Durchläufe vermeiden',
    'angular.pitfalls.antiPatterns.title': 'Anti-Patterns',
    'angular.pitfalls.antiPatterns.description': 'Häufige Fehler in der Angular-Architektur',

    // Resources
    'angular.resources.official.title': 'Offizielle Dokumentation',
    'angular.resources.official.description': 'Angular.dev, GitHub Repository und offizielle Ressourcen',
    'angular.resources.community.title': 'Community & Support',
    'angular.resources.community.description': 'Discord, Reddit, Stack Overflow und Meetups',
    'angular.resources.learning.title': 'Online Kurse',
    'angular.resources.learning.description': 'Hochwertige Lernplattformen für Angular',
    'angular.resources.youtube.title': 'YouTube Channels',
    'angular.resources.youtube.description': 'Tutorials, Updates und Best Practices',
    'angular.resources.blogs.title': 'Blogs & Artikel',
    'angular.resources.blogs.description': 'Technische Deep-Dives und News',
    'angular.resources.tools.title': 'Entwickler-Tools',
    'angular.resources.tools.description': 'DevTools, Playgrounds und Dokumentations-Tools',
    'angular.resources.libraries.title': 'UI Libraries',
    'angular.resources.libraries.description': 'Component Libraries und State Management',
    'angular.resources.newsletters.title': 'Newsletters',
    'angular.resources.newsletters.description': 'Wöchentliche Updates und Neuigkeiten',

    // Crypto Detail Modal
    'crypto.detail.loading': 'Lade Details...',
    'crypto.detail.loadingSubtitle': 'Detaillierte Informationen werden geladen',
    'crypto.detail.error.title': 'Fehler beim Laden',
    'crypto.detail.error.retry': 'Erneut versuchen',
    'crypto.detail.close': 'Schließen',
    'crypto.detail.rank': 'Marktplatz',
    'crypto.detail.currentPrice': 'Aktueller Preis',
    'crypto.detail.marketStats': 'Marktstatistiken',
    'crypto.detail.marketCap': 'Marktkapitalisierung',
    'crypto.detail.volume24h': '24h Volumen',
    'crypto.detail.high24h': '24h Hoch',
    'crypto.detail.low24h': '24h Tief',
    'crypto.detail.supply': 'Versorgung',
    'crypto.detail.circulatingSupply': 'Umlaufende Versorgung',
    'crypto.detail.totalSupply': 'Gesamtversorgung',
    'crypto.detail.maxSupply': 'Maximale Versorgung',
    'crypto.detail.records': 'Rekorde',
    'crypto.detail.allTimeHigh': 'Allzeithoch',
    'crypto.detail.allTimeLow': 'Allzeittief',
    'crypto.detail.about': 'Über',
    'crypto.detail.links': 'Links',
    'crypto.detail.website': 'Website',

    // Common
    'common.close': 'Schließen',

    // Angular Summary Dialog
    'angularSummary.explanation': 'Erklärung',
    'angularSummary.codeExample': 'Code-Beispiel',
    'angularSummary.benefits': 'Vorteile',
    'angularSummary.useCases': 'Anwendungsfälle',
    'angularSummary.example': 'Beispiel',
    'angularSummary.detailedPractices': 'Detaillierte Best Practices',
    'angularSummary.antiPatterns': 'Zu vermeiden',
    'angularSummary.quickTips': 'Quick Tips',

    // Angular Features Details
    'angular.features.signals.detailTitle': 'Signals - Reaktive Programmierung',
    'angular.features.signals.explanation': 'Signals sind Angulars neue reaktive Primitive für effizientes State Management. Sie bieten fine-grained Reactivity und automatisches Dependency Tracking ohne Zone.js.',
    'angular.features.signals.benefit1': 'Automatische Dependency Detection',
    'angular.features.signals.benefit2': 'Keine Zone.js Overhead',
    'angular.features.signals.benefit3': 'Type-safe und entwicklerfreundlich',
    'angular.features.signals.useCase1': 'Component State Management',
    'angular.features.signals.useCase2': 'Computed Values und Derived State',
    'angular.features.signals.useCase3': 'Cross-Component Communication',

    'angular.features.standalone.detailTitle': 'Standalone Components - Modulfreie Architektur',
    'angular.features.standalone.explanation': 'Standalone Components eliminieren NgModules und vereinfachen die Angular-Architektur drastisch. Jede Component deklariert ihre Dependencies direkt.',
    'angular.features.standalone.benefit1': 'Keine NgModule Boilerplate',
    'angular.features.standalone.benefit2': 'Besseres Tree-Shaking',
    'angular.features.standalone.benefit3': 'Einfacheres Lazy Loading',
    'angular.features.standalone.useCase1': 'Micro-Frontend Architektur',
    'angular.features.standalone.useCase2': 'Wiederverwendbare UI-Komponenten',
    'angular.features.standalone.useCase3': 'Simplified Testing Setup',

    'angular.features.inject.detailTitle': 'inject() Function - Moderne Dependency Injection',
    'angular.features.inject.explanation': 'Die inject() Funktion ermöglicht Dependency Injection außerhalb von Konstruktoren - in Funktionen, Factories und sogar in class properties.',
    'angular.features.inject.benefit1': 'Kein Constructor Boilerplate',
    'angular.features.inject.benefit2': 'Funktionale DI möglich',
    'angular.features.inject.benefit3': 'Bessere Lesbarkeit',
    'angular.features.inject.useCase1': 'Functional Guards und Resolvers',
    'angular.features.inject.useCase2': 'Factory Functions',
    'angular.features.inject.useCase3': 'Class Property Initialization',

    'angular.features.controlFlow.detailTitle': 'Control Flow - Neue Template Syntax',
    'angular.features.controlFlow.explanation': 'Neue eingebaute Control Flow Syntax (@if, @for, @switch) ersetzt strukturelle Direktiven mit besserer Performance und Developer Experience.',
    'angular.features.controlFlow.benefit1': 'Bessere Performance',
    'angular.features.controlFlow.benefit2': 'Type Safety in Templates',
    'angular.features.controlFlow.benefit3': 'Intuitiver @empty Block',
    'angular.features.controlFlow.useCase1': 'Konditionales Rendering',
    'angular.features.controlFlow.useCase2': 'Listen mit Track-By',
    'angular.features.controlFlow.useCase3': 'Switch-Case Logic',

    'angular.features.deferrable.detailTitle': 'Deferrable Views - Smart Lazy Loading',
    'angular.features.deferrable.explanation': '@defer ermöglicht deklaratives Lazy Loading von Template-Blöcken mit verschiedenen Trigger-Strategien: viewport, interaction, timer, idle.',
    'angular.features.deferrable.benefit1': 'Automatisches Code Splitting',
    'angular.features.deferrable.benefit2': 'Verbesserte Initial Load Time',
    'angular.features.deferrable.benefit3': 'Deklaratives API',
    'angular.features.deferrable.useCase1': 'Below-the-Fold Content',
    'angular.features.deferrable.useCase2': 'Modal-Inhalte',
    'angular.features.deferrable.useCase3': 'Analytics und Tracking',

    'angular.features.inputOutput.detailTitle': 'input()/output() - Signal-based Component API',
    'angular.features.inputOutput.explanation': 'Die neuen input() und output() Funktionen ersetzen @Input/@Output Decorators mit Signal-basierter API für bessere Typsicherheit.',
    'angular.features.inputOutput.benefit1': 'Signal-basiert und reaktiv',
    'angular.features.inputOutput.benefit2': 'Transform Functions eingebaut',
    'angular.features.inputOutput.benefit3': 'Required Inputs mit Type Safety',
    'angular.features.inputOutput.useCase1': 'Component Props',
    'angular.features.inputOutput.useCase2': 'Event Emitter',
    'angular.features.inputOutput.useCase3': 'Input Transformation',

    'angular.features.viewQueries.detailTitle': 'viewChild()/viewChildren() - Signal Query Functions',
    'angular.features.viewQueries.explanation': 'Neue Signal-basierte Query Functions ersetzen @ViewChild/@ViewChildren Decorators und geben automatisch Signals zurück.',
    'angular.features.viewQueries.benefit1': 'Automatisch Signals',
    'angular.features.viewQueries.benefit2': 'Keine Lifecycle Hooks nötig',
    'angular.features.viewQueries.benefit3': 'Required Queries',
    'angular.features.viewQueries.useCase1': 'Template References',
    'angular.features.viewQueries.useCase2': 'Child Component Access',
    'angular.features.viewQueries.useCase3': 'Direkter DOM-Zugriff',

    'angular.features.model.detailTitle': 'model() - Two-Way Binding mit Signals',
    'angular.features.model.explanation': 'Die model() Funktion ermöglicht echtes Two-Way Data Binding mit Signals - perfekt für Formular-Komponenten und wiederverwendbare Controls.',
    'angular.features.model.benefit1': 'Echtzeit Two-Way Binding',
    'angular.features.model.benefit2': 'Signal-basiert',
    'angular.features.model.benefit3': 'Weniger Boilerplate',
    'angular.features.model.useCase1': 'Custom Form Controls',
    'angular.features.model.useCase2': 'Input Components',
    'angular.features.model.useCase3': 'Synchronized State',

    'angular.features.onPush.detailTitle': 'OnPush Change Detection - Performance Optimization',
    'angular.features.onPush.explanation': 'OnPush Change Detection triggert nur bei Input-Änderungen, Events oder Manual Marking. Mit Signals automatisch optimiert.',
    'angular.features.onPush.benefit1': 'Drastisch weniger CD-Zyklen',
    'angular.features.onPush.benefit2': 'Bessere Performance',
    'angular.features.onPush.benefit3': 'Signal-Updates triggern automatisch',
    'angular.features.onPush.useCase1': 'Große Listen',
    'angular.features.onPush.useCase2': 'Performance-kritische Komponenten',
    'angular.features.onPush.useCase3': 'Immutable Data Patterns',

    'angular.features.httpClient.detailTitle': 'HttpClient - Type-Safe HTTP Requests',
    'angular.features.httpClient.explanation': 'Angulars HttpClient bietet vollständig typisierte HTTP-Requests mit RxJS Observables und kann mit toSignal() in Signals konvertiert werden.',
    'angular.features.httpClient.benefit1': 'Vollständig typisiert',
    'angular.features.httpClient.benefit2': 'Interceptor Support',
    'angular.features.httpClient.benefit3': 'Automatisches JSON Parsing',
    'angular.features.httpClient.useCase1': 'REST API Calls',
    'angular.features.httpClient.useCase2': 'File Uploads',
    'angular.features.httpClient.useCase3': 'GraphQL Integration',

    'angular.features.resource.detailTitle': 'Resource API - Declarative Data Loading',
    'angular.features.resource.explanation': 'Die neue Resource API ermöglicht deklaratives Data Loading mit automatischem Loading/Error State Management und Dependency Tracking.',
    'angular.features.resource.benefit1': 'Automatisches State Management',
    'angular.features.resource.benefit2': 'Reaktives Reload bei Dependencies',
    'angular.features.resource.benefit3': 'Loading/Error States eingebaut',
    'angular.features.resource.useCase1': 'API Data Loading',
    'angular.features.resource.useCase2': 'Search mit Debouncing',
    'angular.features.resource.useCase3': 'Pagination',

    'angular.features.forms.detailTitle': 'Typed Reactive Forms - Type-Safe Form Handling',
    'angular.features.forms.explanation': 'Reactive Forms sind jetzt vollständig typisiert und bieten exzellente IDE-Unterstützung mit automatischer Type Inference.',
    'angular.features.forms.benefit1': 'Vollständige Type Safety',
    'angular.features.forms.benefit2': 'Runtime Validation',
    'angular.features.forms.benefit3': 'Reactive Value Changes',
    'angular.features.forms.useCase1': 'Komplexe Formulare',
    'angular.features.forms.useCase2': 'Dynamic Forms',
    'angular.features.forms.useCase3': 'Multi-Step Wizards',

    'angular.features.router.detailTitle': 'Angular Router - Powerful Navigation',
    'angular.features.router.explanation': 'Angulars Router bietet deklaratives Routing mit Lazy Loading, Guards, Resolvers und vollständiger TypeScript-Unterstützung.',
    'angular.features.router.benefit1': 'Lazy Loading Support',
    'angular.features.router.benefit2': 'Functional Guards',
    'angular.features.router.benefit3': 'Type-Safe Parameters',
    'angular.features.router.useCase1': 'SPA Navigation',
    'angular.features.router.useCase2': 'Route Protection',
    'angular.features.router.useCase3': 'Data Preloading',

    'angular.features.material.detailTitle': 'Angular Material - Material Design 3 Components',
    'angular.features.material.explanation': 'Angular Material bietet hochwertige, getestete UI-Komponenten basierend auf Material Design 3 - ready to use und customizable.',
    'angular.features.material.benefit1': 'Production-Ready Components',
    'angular.features.material.benefit2': 'Accessibility eingebaut',
    'angular.features.material.benefit3': 'Theming Support',
    'angular.features.material.useCase1': 'Enterprise Applications',
    'angular.features.material.useCase2': 'Admin Dashboards',
    'angular.features.material.useCase3': 'Data Tables und Forms',

    'angular.features.devtools.detailTitle': 'Angular DevTools - Debugging & Profiling',
    'angular.features.devtools.explanation': 'Angular DevTools ist eine Chrome Extension für das Debugging, Profiling und die Analyse von Angular-Anwendungen mit Component Inspector und Performance Tools.',
    'angular.features.devtools.benefit1': 'Component Tree Visualization',
    'angular.features.devtools.benefit2': 'Performance Profiling',
    'angular.features.devtools.benefit3': 'Signal Value Inspection',
    'angular.features.devtools.useCase1': 'Performance Optimization',
    'angular.features.devtools.useCase2': 'State Debugging',
    'angular.features.devtools.useCase3': 'Change Detection Analysis',

    'angular.features.vite.detailTitle': 'Vite & ESBuild - Lightning Fast Development',
    'angular.features.vite.explanation': 'Angular verwendet Vite für Development und ESBuild für Production Builds - drastisch schnellere Build-Zeiten und Hot Module Replacement.',
    'angular.features.vite.benefit1': 'Instant HMR',
    'angular.features.vite.benefit2': 'Schnelle Dev Server Starts',
    'angular.features.vite.benefit3': 'Optimierte Production Builds',
    'angular.features.vite.useCase1': 'Rapid Development',
    'angular.features.vite.useCase2': 'Large Applications',
    'angular.features.vite.useCase3': 'CI/CD Pipelines',

    // Best Practices Details
    // Components
    'angular.bestPractices.components.detailTitle': 'Komponenten Best Practices',
    'angular.bestPractices.components.explanation': 'Moderne Angular-Komponenten nutzen Standalone Architecture, Signals für reaktiven State und OnPush Change Detection für optimale Performance.',
    'angular.bestPractices.components.benefit1': 'Bessere Wiederverwendbarkeit',
    'angular.bestPractices.components.benefit2': 'Einfacheres Testing',
    'angular.bestPractices.components.benefit3': 'Optimale Performance',
    'angular.bestPractices.components.antiPattern1': 'Logik im Template statt in der Komponente',
    'angular.bestPractices.components.antiPattern2': 'Direkter DOM-Zugriff ohne ViewChild',
    'angular.bestPractices.components.antiPattern3': 'Große Komponenten ohne Aufteilung',

    // State Management
    'angular.bestPractices.state.detailTitle': 'State Management Best Practices',
    'angular.bestPractices.state.explanation': 'Nutze Signals für reaktives State Management mit automatischem Dependency Tracking und minimalen Change Detection Zyklen.',
    'angular.bestPractices.state.benefit1': 'Automatische Updates',
    'angular.bestPractices.state.benefit2': 'Type-Safe State',
    'angular.bestPractices.state.benefit3': 'Immutable Patterns',
    'angular.bestPractices.state.antiPattern1': 'Direktes Mutieren von Arrays/Objects',
    'angular.bestPractices.state.antiPattern2': 'State in mehreren Komponenten duplizieren',
    'angular.bestPractices.state.antiPattern3': 'Keine klare Single Source of Truth',

    // Templates
    'angular.bestPractices.templates.detailTitle': 'Template Best Practices',
    'angular.bestPractices.templates.explanation': 'Verwende die neue Control Flow Syntax (@if, @for, @switch) und @defer für bessere Performance und Developer Experience.',
    'angular.bestPractices.templates.benefit1': 'Bessere Lesbarkeit',
    'angular.bestPractices.templates.benefit2': 'Type Safety',
    'angular.bestPractices.templates.benefit3': 'Optimierte Performance',
    'angular.bestPractices.templates.antiPattern1': 'Komplexe Logik im Template',
    'angular.bestPractices.templates.antiPattern2': '@for ohne track by',
    'angular.bestPractices.templates.antiPattern3': 'Übermäßige Pipe-Nutzung',

    // Services
    'angular.bestPractices.services.detailTitle': 'Service Best Practices',
    'angular.bestPractices.services.explanation': 'Services sollten zustandslos sein, klare Verantwortlichkeiten haben und Signals für reaktive Daten nutzen.',
    'angular.bestPractices.services.benefit1': 'Wiederverwendbarkeit',
    'angular.bestPractices.services.benefit2': 'Einfaches Testing',
    'angular.bestPractices.services.benefit3': 'Klare Separation of Concerns',
    'angular.bestPractices.services.antiPattern1': 'Services mit UI-Logik',
    'angular.bestPractices.services.antiPattern2': 'Fehlende Error Handling',
    'angular.bestPractices.services.antiPattern3': 'Keine Observable-Cleanup',

    // Performance
    'angular.bestPractices.performance.detailTitle': 'Performance Best Practices',
    'angular.bestPractices.performance.explanation': 'Optimiere Performance durch OnPush Change Detection, trackBy in Listen, Lazy Loading und @defer für below-the-fold Content.',
    'angular.bestPractices.performance.benefit1': 'Schnellere Ladezeiten',
    'angular.bestPractices.performance.benefit2': 'Weniger Re-Renders',
    'angular.bestPractices.performance.benefit3': 'Bessere UX',
    'angular.bestPractices.performance.antiPattern1': 'Keine Change Detection Strategy',
    'angular.bestPractices.performance.antiPattern2': 'Große Bundles ohne Code Splitting',
    'angular.bestPractices.performance.antiPattern3': 'Unoptimierte Bilder und Assets',

    // TypeScript
    'angular.bestPractices.typescript.detailTitle': 'TypeScript Best Practices',
    'angular.bestPractices.typescript.explanation': 'Nutze strikte TypeScript-Konfiguration mit allen Compiler-Checks für maximale Typsicherheit und weniger Laufzeitfehler.',
    'angular.bestPractices.typescript.benefit1': 'Fehler zur Compile-Zeit',
    'angular.bestPractices.typescript.benefit2': 'Bessere IDE-Unterstützung',
    'angular.bestPractices.typescript.benefit3': 'Selbstdokumentierender Code',
    'angular.bestPractices.typescript.antiPattern1': 'any-Type verwenden',
    'angular.bestPractices.typescript.antiPattern2': 'Type Assertions missbrauchen',
    'angular.bestPractices.typescript.antiPattern3': 'Strikte Checks deaktivieren',

    // Accessibility
    'angular.bestPractices.accessibility.detailTitle': 'Accessibility Best Practices',
    'angular.bestPractices.accessibility.explanation': 'Stelle sicher, dass deine Anwendung für alle Nutzer zugänglich ist durch semantisches HTML, ARIA-Attribute und Keyboard-Navigation.',
    'angular.bestPractices.accessibility.benefit1': 'Größere Zielgruppe',
    'angular.bestPractices.accessibility.benefit2': 'Bessere SEO',
    'angular.bestPractices.accessibility.benefit3': 'Gesetzliche Compliance',
    'angular.bestPractices.accessibility.antiPattern1': 'Fehlende ARIA-Labels',
    'angular.bestPractices.accessibility.antiPattern2': 'Keine Keyboard-Navigation',
    'angular.bestPractices.accessibility.antiPattern3': 'Schlechte Farbkontraste',

    // Testing
    'angular.bestPractices.testing.detailTitle': 'Testing Best Practices',
    'angular.bestPractices.testing.explanation': 'Schreibe aussagekräftige Tests für Komponenten und Services mit hoher Coverage und klaren Assertions.',
    'angular.bestPractices.testing.benefit1': 'Weniger Bugs',
    'angular.bestPractices.testing.benefit2': 'Sicheres Refactoring',
    'angular.bestPractices.testing.benefit3': 'Lebende Dokumentation',
    'angular.bestPractices.testing.antiPattern1': 'Tests für Implementation statt Behavior',
    'angular.bestPractices.testing.antiPattern2': 'Keine Test-Isolation',
    'angular.bestPractices.testing.antiPattern3': 'Zu viele Mocks',

    // Error Handling
    'angular.bestPractices.errorHandling.detailTitle': 'Error Handling Best Practices',
    'angular.bestPractices.errorHandling.explanation': 'Implementiere globales Error Handling, aussagekräftige Fehlermeldungen und Error Boundaries für robuste Anwendungen.',
    'angular.bestPractices.errorHandling.benefit1': 'Bessere User Experience',
    'angular.bestPractices.errorHandling.benefit2': 'Einfacheres Debugging',
    'angular.bestPractices.errorHandling.benefit3': 'Robustere Anwendungen',
    'angular.bestPractices.errorHandling.antiPattern1': 'Fehler verschlucken',
    'angular.bestPractices.errorHandling.antiPattern2': 'Keine Error Logs',
    'angular.bestPractices.errorHandling.antiPattern3': 'Generische Fehlermeldungen',

    // Security
    'angular.bestPractices.security.detailTitle': 'Security Best Practices',
    'angular.bestPractices.security.explanation': 'Schütze deine Anwendung vor XSS, CSRF und anderen Sicherheitsrisiken durch DomSanitizer, Content Security Policy und sichere HTTP-Praktiken.',
    'angular.bestPractices.security.benefit1': 'Schutz vor XSS-Angriffen',
    'angular.bestPractices.security.benefit2': 'Sichere Datenübertragung',
    'angular.bestPractices.security.benefit3': 'OWASP-Compliance',
    'angular.bestPractices.security.antiPattern1': 'Unsanitized HTML rendern',
    'angular.bestPractices.security.antiPattern2': 'Sensitive Daten im LocalStorage',
    'angular.bestPractices.security.antiPattern3': 'Fehlende HTTPS',

    // Code Organization
    'angular.bestPractices.codeOrganization.detailTitle': 'Code Organization Best Practices',
    'angular.bestPractices.codeOrganization.explanation': 'Organisiere deinen Code nach Features mit klarer Ordnerstruktur, Barrel Exports und Separation of Concerns.',
    'angular.bestPractices.codeOrganization.benefit1': 'Bessere Wartbarkeit',
    'angular.bestPractices.codeOrganization.benefit2': 'Einfachere Onboarding',
    'angular.bestPractices.codeOrganization.benefit3': 'Skalierbare Architektur',
    'angular.bestPractices.codeOrganization.antiPattern1': 'Flache Ordnerstruktur',
    'angular.bestPractices.codeOrganization.antiPattern2': 'Vermischte Concerns',
    'angular.bestPractices.codeOrganization.antiPattern3': 'Keine Namenskonventionen',

    // Dependency Injection
    'angular.bestPractices.dependency.detailTitle': 'Dependency Injection Best Practices',
    'angular.bestPractices.dependency.explanation': 'Nutze inject() für moderne DI, Injection Tokens für Konfiguration und providedIn für Tree-Shakeable Services.',
    'angular.bestPractices.dependency.benefit1': 'Besseres Tree-Shaking',
    'angular.bestPractices.dependency.benefit2': 'Klare Dependencies',
    'angular.bestPractices.dependency.benefit3': 'Einfaches Testing',
    'angular.bestPractices.dependency.antiPattern1': 'Service-Singleton umgehen',
    'angular.bestPractices.dependency.antiPattern2': 'Zirkuläre Dependencies',
    'angular.bestPractices.dependency.antiPattern3': 'Keine Injection Tokens',

    // Build & Deploy
    'angular.bestPractices.buildDeploy.detailTitle': 'Build & Deploy Best Practices',
    'angular.bestPractices.buildDeploy.explanation': 'Optimiere Production Builds mit Budgets, Environment-Variablen und automatisierten CI/CD Pipelines.',
    'angular.bestPractices.buildDeploy.benefit1': 'Schnelle Deployments',
    'angular.bestPractices.buildDeploy.benefit2': 'Kleinere Bundle-Größen',
    'angular.bestPractices.buildDeploy.benefit3': 'Automatisierte Qualitätschecks',
    'angular.bestPractices.buildDeploy.antiPattern1': 'Keine Build Budgets',
    'angular.bestPractices.buildDeploy.antiPattern2': 'Secrets im Code',
    'angular.bestPractices.buildDeploy.antiPattern3': 'Manuelle Deployments',

    // Advanced Topics Details
    'angular.advanced.routing.detailTitle': 'Fortgeschrittenes Routing',
    'angular.advanced.routing.explanation': 'Modernes Angular Routing mit funktionalen Guards, Resolvern und Code-Splitting für optimale Performance.',
    'angular.advanced.routing.benefit1': 'Code-Splitting & Lazy Loading',
    'angular.advanced.routing.benefit2': 'Type-safe Guards & Resolver',
    'angular.advanced.routing.benefit3': 'Optimierte Navigation',
    'angular.advanced.routing.antiPattern1': 'Keine Lazy Loading Strategie',
    'angular.advanced.routing.antiPattern2': 'Fehlende Guard-Implementierung',
    'angular.advanced.routing.antiPattern3': 'Unstrukturierte Route-Definitionen',

    'angular.advanced.forms.detailTitle': 'Reaktive Formulare',
    'angular.advanced.forms.explanation': 'Typed Reactive Forms mit TypeScript-Typsicherheit, Custom Validators und asynchroner Validierung für komplexe Formulare.',
    'angular.advanced.forms.benefit1': 'Vollständige Typsicherheit',
    'angular.advanced.forms.benefit2': 'Reaktive Validierung',
    'angular.advanced.forms.benefit3': 'Wiederverwendbare Validators',
    'angular.advanced.forms.antiPattern1': 'Template-driven Forms für komplexe Logik',
    'angular.advanced.forms.antiPattern2': 'Fehlende Fehlerbehandlung',
    'angular.advanced.forms.antiPattern3': 'Keine Custom Validators',

    'angular.advanced.rxjs.detailTitle': 'RxJS Mastery',
    'angular.advanced.rxjs.explanation': 'Fortgeschrittene RxJS-Patterns mit Higher-Order Observables, Error Handling und Memory Leak Prevention.',
    'angular.advanced.rxjs.benefit1': 'Effizientes Stream-Management',
    'angular.advanced.rxjs.benefit2': 'Automatisches Error Handling',
    'angular.advanced.rxjs.benefit3': 'Memory Leak Prevention',
    'angular.advanced.rxjs.antiPattern1': 'Fehlende Unsubscribe-Logik',
    'angular.advanced.rxjs.antiPattern2': 'Nested Subscriptions',
    'angular.advanced.rxjs.antiPattern3': 'Kein Error Handling',

    'angular.advanced.changeDetection.detailTitle': 'Change Detection Optimierung',
    'angular.advanced.changeDetection.explanation': 'OnPush Change Detection, Signals und Zone-less Angular für maximale Performance-Optimierung.',
    'angular.advanced.changeDetection.benefit1': 'Deutlich weniger Checks',
    'angular.advanced.changeDetection.benefit2': 'Bessere Performance',
    'angular.advanced.changeDetection.benefit3': 'Zone-less möglich',
    'angular.advanced.changeDetection.antiPattern1': 'Default Change Detection überall',
    'angular.advanced.changeDetection.antiPattern2': 'Mutable State Updates',
    'angular.advanced.changeDetection.antiPattern3': 'Fehlende markForCheck() Aufrufe',

    'angular.advanced.animations.detailTitle': 'Angular Animations',
    'angular.advanced.animations.explanation': 'Komplexe Animationen mit State Management, Route Transitions und Stagger Effects für moderne UIs.',
    'angular.advanced.animations.benefit1': 'Flüssige UI-Übergänge',
    'angular.advanced.animations.benefit2': 'Deklarative Syntax',
    'angular.advanced.animations.benefit3': 'Performance-optimiert',
    'angular.advanced.animations.antiPattern1': 'CSS-Animationen in Components',
    'angular.advanced.animations.antiPattern2': 'Fehlende Animation-Callbacks',
    'angular.advanced.animations.antiPattern3': 'Zu komplexe Animationen',

    'angular.advanced.testing.detailTitle': 'Fortgeschrittenes Testing',
    'angular.advanced.testing.explanation': 'Umfassende Test-Strategien mit Component Tests, Service Tests, HTTP Mocking und E2E Testing.',
    'angular.advanced.testing.benefit1': 'Hohe Code-Qualität',
    'angular.advanced.testing.benefit2': 'Sichere Refactorings',
    'angular.advanced.testing.benefit3': 'Automatisierte Regression Tests',
    'angular.advanced.testing.antiPattern1': 'Implementierung statt Verhalten testen',
    'angular.advanced.testing.antiPattern2': 'Fehlende Test-Isolation',
    'angular.advanced.testing.antiPattern3': 'Keine HTTP-Tests',

    'angular.advanced.ssr.detailTitle': 'Server-Side Rendering',
    'angular.advanced.ssr.explanation': 'Angular Universal für SEO, Performance und bessere First Contentful Paint mit Transfer State.',
    'angular.advanced.ssr.benefit1': 'Bessere SEO',
    'angular.advanced.ssr.benefit2': 'Schnellerer Initial Load',
    'angular.advanced.ssr.benefit3': 'Verbesserte Performance',
    'angular.advanced.ssr.antiPattern1': 'Browser-APIs im Server-Code',
    'angular.advanced.ssr.antiPattern2': 'Fehlende Platform Checks',
    'angular.advanced.ssr.antiPattern3': 'Kein Transfer State',

    'angular.advanced.i18n.detailTitle': 'Internationalisierung',
    'angular.advanced.i18n.explanation': 'Runtime i18n mit Signal-based Service für dynamischen Sprachwechsel und optimales UX.',
    'angular.advanced.i18n.benefit1': 'Dynamischer Sprachwechsel',
    'angular.advanced.i18n.benefit2': 'Lazy-loaded Translations',
    'angular.advanced.i18n.benefit3': 'Type-safe Keys',
    'angular.advanced.i18n.antiPattern1': 'Hardcoded Strings',
    'angular.advanced.i18n.antiPattern2': 'Alle Sprachen im Bundle',
    'angular.advanced.i18n.antiPattern3': 'Fehlende Pluralization',

    'angular.advanced.security.detailTitle': 'Security Best Practices',
    'angular.advanced.security.explanation': 'Umfassende Sicherheit mit DomSanitizer, CSP, CSRF-Protection und sichere HTTP-Kommunikation.',
    'angular.advanced.security.benefit1': 'XSS-Schutz',
    'angular.advanced.security.benefit2': 'CSRF-Protection',
    'angular.advanced.security.benefit3': 'Content Security Policy',
    'angular.advanced.security.antiPattern1': 'Unsanitized HTML Rendering',
    'angular.advanced.security.antiPattern2': 'Tokens in LocalStorage',
    'angular.advanced.security.antiPattern3': 'Fehlende CSP Headers',

    'angular.advanced.directives.detailTitle': 'Custom Directives',
    'angular.advanced.directives.explanation': 'Structural und Attribute Directives für wiederverwendbare DOM-Manipulation und erweiterte Funktionalität.',
    'angular.advanced.directives.benefit1': 'Wiederverwendbare Logik',
    'angular.advanced.directives.benefit2': 'Saubere Templates',
    'angular.advanced.directives.benefit3': 'Host Binding Power',
    'angular.advanced.directives.antiPattern1': 'Direkte DOM-Manipulation',
    'angular.advanced.directives.antiPattern2': 'Zu komplexe Directives',
    'angular.advanced.directives.antiPattern3': 'Fehlende Error Handling',

    'angular.advanced.pipes.detailTitle': 'Custom Pipes',
    'angular.advanced.pipes.explanation': 'Pure und Impure Pipes für Daten-Transformation, mit Performance-Optimierungen und Memoization.',
    'angular.advanced.pipes.benefit1': 'Wiederverwendbare Transformationen',
    'angular.advanced.pipes.benefit2': 'Template-Logik reduziert',
    'angular.advanced.pipes.benefit3': 'Automatic Caching (Pure)',
    'angular.advanced.pipes.antiPattern1': 'Impure Pipes ohne Grund',
    'angular.advanced.pipes.antiPattern2': 'Komplexe Logik in Pipes',
    'angular.advanced.pipes.antiPattern3': 'Fehlende Type Safety',

    'angular.advanced.httpInterceptors.detailTitle': 'HTTP Interceptors',
    'angular.advanced.httpInterceptors.explanation': 'Funktionale Interceptors für Auth, Logging, Error Handling und Request/Response-Transformation.',
    'angular.advanced.httpInterceptors.benefit1': 'Zentrale HTTP-Logik',
    'angular.advanced.httpInterceptors.benefit2': 'Automatische Auth-Headers',
    'angular.advanced.httpInterceptors.benefit3': 'Globales Error Handling',
    'angular.advanced.httpInterceptors.antiPattern1': 'Interceptor-Reihenfolge ignorieren',
    'angular.advanced.httpInterceptors.antiPattern2': 'Zu viele Interceptors',
    'angular.advanced.httpInterceptors.antiPattern3': 'Fehlende Error Propagation',

    'angular.advanced.stateManagement.detailTitle': 'State Management',
    'angular.advanced.stateManagement.explanation': 'Signal-based Stores für reaktives State Management mit Computed Values und Immutability.',
    'angular.advanced.stateManagement.benefit1': 'Zentrale State-Verwaltung',
    'angular.advanced.stateManagement.benefit2': 'Reactive Updates',
    'angular.advanced.stateManagement.benefit3': 'Immutable State',
    'angular.advanced.stateManagement.antiPattern1': 'State in Components',
    'angular.advanced.stateManagement.antiPattern2': 'Mutable State Updates',
    'angular.advanced.stateManagement.antiPattern3': 'Keine Single Source of Truth',

    'angular.advanced.moduleFederation.detailTitle': 'Module Federation',
    'angular.advanced.moduleFederation.explanation': 'Micro-Frontend Architektur mit Webpack Module Federation für skalierbare Enterprise-Anwendungen.',
    'angular.advanced.moduleFederation.benefit1': 'Unabhängige Deployments',
    'angular.advanced.moduleFederation.benefit2': 'Team-Skalierbarkeit',
    'angular.advanced.moduleFederation.benefit3': 'Shared Dependencies',
    'angular.advanced.moduleFederation.antiPattern1': 'Tight Coupling zwischen MFEs',
    'angular.advanced.moduleFederation.antiPattern2': 'Keine Version Strategies',
    'angular.advanced.moduleFederation.antiPattern3': 'Zu kleine MFEs',

    'angular.advanced.pwa.detailTitle': 'Progressive Web Apps',
    'angular.advanced.pwa.explanation': 'Offline-First PWAs mit Service Worker, Caching-Strategien und Push-Notifications.',
    'angular.advanced.pwa.benefit1': 'Offline-Funktionalität',
    'angular.advanced.pwa.benefit2': 'Install-fähig',
    'angular.advanced.pwa.benefit3': 'Push Notifications',
    'angular.advanced.pwa.antiPattern1': 'Zu aggressives Caching',
    'angular.advanced.pwa.antiPattern2': 'Fehlende Update-Strategie',
    'angular.advanced.pwa.antiPattern3': 'Keine Offline-Fallbacks',

    // Footer
    'footer.copyright': '2025 Mike Diethelm. Built with Angular 20.',
    'footer.github.title': 'GitHub Profile',
    'footer.linkedin.title': 'LinkedIn Profile',
    'footer.techstack': 'Angular • Material Design 3 • TypeScript'
};
